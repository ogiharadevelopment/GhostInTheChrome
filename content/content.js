const GHOST_I18N_STRINGS = {
  bookmarks: {
    ja: 'ブックマーク',
    en: 'Bookmarks',
    'zh-CN': '书签',
    fr: 'Signets',
    es: 'Marcadores',
    de: 'Lesezeichen'
  },
  history: {
    ja: '履歴',
    en: 'History',
    'zh-CN': '历史记录',
    fr: 'Historique',
    es: 'Historial',
    de: 'Verlauf'
  },
  favorites: {
    ja: 'お気に入り',
    en: 'Favorites',
    'zh-CN': '收藏夹',
    fr: 'Favoris',
    es: 'Favoritos',
    de: 'Favoriten'
  },
  recentlyClosed: {
    ja: '最近閉じたタブ',
    en: 'Recently Closed',
    'zh-CN': '最近关闭的标签页',
    fr: 'Onglets récemment fermés',
    es: 'Pestañas cerradas recientemente',
    de: 'Zuletzt geschlossene Tabs'
  },
  collection: {
    ja: 'コレクション',
    en: 'Collection',
    'zh-CN': '集合',
    fr: 'Collection',
    es: 'Colección',
    de: 'Sammlung'
  },
  keylist: {
    ja: 'キーリスト',
    en: 'Key List',
    'zh-CN': '按键列表',
    fr: 'Liste de touches',
    es: 'Lista de teclas',
    de: 'Tastenliste'
  },
  favoriteAdded: {
    ja: 'GhostFABに追加',
    en: 'Added to GhostFAB',
    'zh-CN': '已添加到 GhostFAB',
    fr: 'Ajouté à GhostFAB',
    es: 'Añadido a GhostFAB',
    de: 'Zu GhostFAB hinzugefügt'
  },
  favoriteRemoved: {
    ja: 'GhostFABから削除',
    en: 'Removed from GhostFAB',
    'zh-CN': '已从 GhostFAB 移除',
    fr: 'Retiré de GhostFAB',
    es: 'Eliminado de GhostFAB',
    de: 'Aus GhostFAB entfernt'
  },
  notification_unsupported_key: {
    ja: '対応していないキーです',
    en: 'This key is not supported',
    'zh-CN': '不支持此按键',
    fr: 'Cette touche n\'est pas prise en charge',
    es: 'Esta tecla no es compatible',
    de: 'Diese Taste wird nicht unterstützt'
  },
  notification_no_tabs_available: {
    ja: '保存できるタブがありません',
    en: 'There are no tabs to save',
    'zh-CN': '没有可保存的标签页',
    fr: 'Aucun onglet à enregistrer',
    es: 'No hay pestañas para guardar',
    de: 'Es gibt keine Tabs zum Speichern'
  },
  notification_no_savable_tabs: {
    ja: '保存可能なタブがありません',
    en: 'No savable tabs were found',
    'zh-CN': '没有可保存的标签页',
    fr: 'Aucun onglet enregistrable trouvé',
    es: 'No se encontraron pestañas guardables',
    de: 'Es wurden keine speicherbaren Tabs gefunden'
  },
  notification_overwrite_cancelled: {
    ja: '上書きをキャンセルしました',
    en: 'Overwrite cancelled',
    'zh-CN': '已取消覆盖',
    fr: 'Écrasement annulé',
    es: 'Sobrescritura cancelada',
    de: 'Überschreiben abgebrochen'
  },
  notification_collection_saved: {
    ja: 'コレクション「$1」を保存しました',
    en: 'Saved collection "$1"',
    'zh-CN': '已保存集合"$1"',
    fr: 'Collection « $1 » enregistrée',
    es: 'Colección "$1" guardada',
    de: 'Sammlung "$1" gespeichert'
  },
  notification_collection_save_failed: {
    ja: 'コレクションの保存に失敗しました',
    en: 'Failed to save the collection',
    'zh-CN': '保存集合失败',
    fr: 'Échec de l\'enregistrement de la collection',
    es: 'No se pudo guardar la colección',
    de: 'Speichern der Sammlung fehlgeschlagen'
  },
  confirm_overwrite_collection: {
    ja: 'キー「$1」のコレクションを上書きしますか？',
    en: 'Overwrite the collection saved on key "$1"?',
    'zh-CN': '要覆盖按键"$1"的集合吗？',
    fr: 'Écraser la collection enregistrée sur la touche « $1 » ?',
    es: '¿Sobrescribir la colección guardada en la tecla "$1"?',
    de: 'Die auf Taste "$1" gespeicherte Sammlung überschreiben?'
  },
  notification_collection_empty: {
    ja: 'キー「$1」のコレクションは空です',
    en: 'The collection on key "$1" is empty',
    'zh-CN': '按键"$1"的集合为空',
    fr: 'La collection de la touche « $1 » est vide',
    es: 'La colección de la tecla "$1" está vacía',
    de: 'Die Sammlung auf Taste "$1" ist leer'
  },
  collection_header_title: {
    ja: 'コレクション「$1」（$2タブ）',
    en: 'Collection "$1" ($2 tabs)',
    'zh-CN': '集合"$1"（$2 个标签页）',
    fr: 'Collection « $1 » ($2 onglets)',
    es: 'Colección "$1" ($2 pestañas)',
    de: 'Sammlung "$1" ($2 Tabs)'
  },
  collection_tab_count_label: {
    ja: '$1 件',
    en: '$1 tabs',
    'zh-CN': '$1 个',
    fr: '$1 onglets',
    es: '$1 pestañas',
    de: '$1 Tabs'
  },
  collection_saved_label: {
    ja: '保存: $1',
    en: 'Saved: $1',
    'zh-CN': '保存：$1',
    fr: 'Enregistré : $1',
    es: 'Guardado: $1',
    de: 'Gespeichert: $1'
  },
  collection_updated_label: {
    ja: '更新: $1',
    en: 'Updated: $1',
    'zh-CN': '更新：$1',
    fr: 'Mis à jour : $1',
    es: 'Actualizado: $1',
    de: 'Aktualisiert: $1'
  },
  collection_edit_button: {
    ja: '編集',
    en: 'Edit',
    'zh-CN': '编辑',
    fr: 'Modifier',
    es: 'Editar',
    de: 'Bearbeiten'
  },
  collection_export_button: {
    ja: 'JSON保存',
    en: 'Export JSON',
    'zh-CN': '导出 JSON',
    fr: 'Exporter en JSON',
    es: 'Exportar JSON',
    de: 'JSON exportieren'
  },
  collection_note_empty: {
    ja: 'メモはありません',
    en: 'No note available',
    'zh-CN': '没有备注',
    fr: 'Aucune note',
    es: 'Sin nota',
    de: 'Keine Notiz vorhanden'
  },
  collection_open_single_button: {
    ja: '開く',
    en: 'Open',
    'zh-CN': '打开',
    fr: 'Ouvrir',
    es: 'Abrir',
    de: 'Öffnen'
  },
  collection_remove_button: {
    ja: '削除',
    en: 'Remove',
    'zh-CN': '删除',
    fr: 'Supprimer',
    es: 'Eliminar',
    de: 'Entfernen'
  },
  notification_no_saved_pages_for_key: {
    ja: 'キー「$1」に保存されたページはありません',
    en: 'There are no pages saved on key "$1"',
    'zh-CN': '按键"$1"未保存任何页面',
    fr: 'Aucune page enregistrée sur la touche « $1 »',
    es: 'No hay páginas guardadas en la tecla "$1"',
    de: 'Auf Taste "$1" sind keine Seiten gespeichert'
  },
  confirm_open_key_items: {
    ja: 'キー「$1」の$2件を新しいタブで開きますか？',
    en: 'Open $2 items from key "$1" in new tabs?',
    'zh-CN': '要在新标签页中打开按键"$1"的 $2 个项目吗？',
    fr: 'Ouvrir $2 éléments de la touche « $1 » dans de nouveaux onglets ?',
    es: '¿Abrir $2 elementos de la tecla "$1" en pestañas nuevas?',
    de: '$2 Elemente von Taste "$1" in neuen Tabs öffnen?'
  },
  notification_open_cancelled: {
    ja: '開封をキャンセルしました',
    en: 'Opening cancelled',
    'zh-CN': '已取消打开',
    fr: 'Ouverture annulée',
    es: 'Apertura cancelada',
    de: 'Öffnen abgebrochen'
  },
  notification_collection_not_found: {
    ja: 'キー「$1」のコレクションは見つかりません',
    en: 'No collection found on key "$1"',
    'zh-CN': '按键"$1"未找到集合',
    fr: 'Aucune collection trouvée sur la touche « $1 »',
    es: 'No se encontró una colección en la tecla "$1"',
    de: 'Keine Sammlung auf Taste "$1" gefunden'
  },
  confirm_open_collection: {
    ja: 'コレクション「$1」の$2件を開き直しますか？',
    en: 'Reopen $2 items from collection "$1"?',
    'zh-CN': '要重新打开集合"$1"的 $2 个项目吗？',
    fr: 'Rouvrir $2 éléments de la collection « $1 » ?',
    es: '¿Volver a abrir $2 elementos de la colección "$1"?',
    de: '$2 Elemente der Sammlung "$1" erneut öffnen?'
  },
  confirm_restore_collection_close_tabs: {
    ja: '現在のウィンドウには$1件のタブがあります。閉じてコレクション「$2」（$3件）を開き直しますか？',
    en: 'The current window has $1 tabs. Close them and reopen collection "$2" ($3 items)?',
    'zh-CN': '当前窗口有 $1 个标签页。关闭它们并重新打开集合"$2"（$3 个项目）吗？',
    fr: 'La fenêtre actuelle contient $1 onglets. Les fermer et rouvrir la collection « $2 » ($3 éléments) ?',
    es: 'La ventana actual tiene $1 pestañas. ¿Cerrarlas y volver a abrir la colección "$2" ($3 elementos)?',
    de: 'Dieses Fenster enthält $1 Tabs. Sollen sie geschlossen und die Sammlung "$2" ($3 Elemente) neu geöffnet werden?'
  },
  notification_restore_cancelled: {
    ja: '復元をキャンセルしました',
    en: 'Restore cancelled',
    'zh-CN': '已取消还原',
    fr: 'Restauration annulée',
    es: 'Restauración cancelada',
    de: 'Wiederherstellung abgebrochen'
  },
  notification_collection_restore_failed: {
    ja: 'コレクションの復元に失敗しました',
    en: 'Failed to restore the collection',
    'zh-CN': '恢复集合失败',
    fr: 'Échec de la restauration de la collection',
    es: 'No se pudo restaurar la colección',
    de: 'Wiederherstellung der Sammlung fehlgeschlagen'
  },
  notification_collection_restored: {
    ja: 'コレクション「$1」を復元しました',
    en: 'Restored collection "$1"',
    'zh-CN': '已恢复集合"$1"',
    fr: 'Collection « $1 » restaurée',
    es: 'Colección "$1" restaurada',
    de: 'Sammlung "$1" wurde wiederhergestellt'
  },
  notification_json_downloaded: {
    ja: 'JSONファイルをダウンロードしました',
    en: 'Downloaded JSON file',
    'zh-CN': '已下载 JSON 文件',
    fr: 'Fichier JSON téléchargé',
    es: 'Archivo JSON descargado',
    de: 'JSON-Datei heruntergeladen'
  },
  confirm_remove_tab_from_collection: {
    ja: '「$1」をコレクションから削除しますか？',
    en: 'Remove "$1" from the collection?',
    'zh-CN': '要从集合中删除"$1"吗？',
    fr: 'Supprimer « $1 » de la collection ?',
    es: '¿Eliminar "$1" de la colección?',
    de: '„$1" aus der Sammlung entfernen?'
  },
  notification_collection_deleted_empty: {
    ja: 'コレクション「$1」は空になったため削除しました',
    en: 'Collection "$1" was removed because it became empty',
    'zh-CN': '集合"$1"已为空，已删除',
    fr: 'La collection « $1 » a été supprimée car elle était vide',
    es: 'La colección "$1" se eliminó porque quedó vacía',
    de: 'Sammlung "$1" wurde gelöscht, da sie leer war'
  },
  prompt_collection_name: {
    ja: 'コレクション名を入力してください',
    en: 'Enter a collection name',
    'zh-CN': '请输入集合名称',
    fr: 'Saisissez le nom de la collection',
    es: 'Introduce el nombre de la colección',
    de: 'Geben Sie einen Sammlungsnamen ein'
  },
  prompt_collection_note: {
    ja: 'メモを入力してください（空欄可）',
    en: 'Enter a note (optional)',
    'zh-CN': '请输入备注（可留空）',
    fr: 'Saisissez une note (facultatif)',
    es: 'Introduce una nota (opcional)',
    de: 'Geben Sie eine Notiz ein (optional)'
  },
  notification_collection_updated: {
    ja: 'コレクション情報を更新しました',
    en: 'Collection information updated',
    'zh-CN': '集合信息已更新',
    fr: 'Informations sur la collection mises à jour',
    es: 'Información de la colección actualizada',
    de: 'Sammlungsinformationen aktualisiert'
  },
  notification_export_target_missing: {
    ja: 'エクスポート対象が見つかりません',
    en: 'Export target not found',
    'zh-CN': '未找到可导出的对象',
    fr: 'Aucune donnée à exporter',
    es: 'No se encontró contenido para exportar',
    de: 'Kein Exportziel gefunden'
  },
  confirm_export_collection: {
    ja: 'コレクション「$1」をJSONファイルとして保存しますか？',
    en: 'Save collection "$1" as a JSON file?',
    'zh-CN': '要将集合"$1"保存为 JSON 文件吗？',
    fr: 'Enregistrer la collection « $1 » au format JSON ?',
    es: '¿Guardar la colección "$1" como archivo JSON?',
    de: 'Sammlung "$1" als JSON-Datei speichern?'
  },
  alert_select_plan: {
    ja: 'このメッセージは使用されていません。',
    en: 'This message is no longer used.',
    'zh-CN': '此消息已不再使用。',
    fr: 'Ce message n\'est plus utilisé.',
    es: 'Este mensaje ya no se utiliza.',
    de: 'Diese Meldung wird nicht mehr verwendet.'
  },
  alert_subscription_failed: {
    ja: 'このメッセージは使用されていません。',
    en: 'This message is no longer used.',
    'zh-CN': '此消息已不再使用。',
    fr: 'Ce message n\'est plus utilisé.',
    es: 'Este mensaje ya no se utiliza.',
    de: 'Diese Meldung wird nicht mehr verwendet.'
  },
  content_subscription_updated: {
    ja: 'このメッセージは使用されていません。',
    en: 'This message is no longer used.',
    'zh-CN': '此消息已不再使用。',
    fr: 'Ce message n\'est plus utilisé.',
    es: 'Este mensaje ya no se utiliza.',
    de: 'Diese Meldung wird nicht mehr verwendet.'
  },
  notification_recently_closed_empty: {
    ja: '最近閉じたタブはありません',
    en: 'No recently closed tabs available',
    'zh-CN': '没有最近关闭的标签页',
    fr: 'Aucun onglet récemment fermé',
    es: 'No hay pestañas cerradas recientemente',
    de: 'Keine kürzlich geschlossenen Tabs'
  },
  restore_option_existing_window: {
    ja: '既存のウィンドウに開く',
    en: 'Open in existing window',
    'zh-CN': '在现有窗口中打开',
    fr: 'Ouvrir dans la fenêtre existante',
    es: 'Abrir en la ventana existente',
    de: 'In vorhandenem Fenster öffnen'
  },
  restore_option_new_window: {
    ja: '新しいウィンドウを開く',
    en: 'Open in new window',
    'zh-CN': '在新窗口中打开',
    fr: 'Ouvrir dans une nouvelle fenêtre',
    es: 'Abrir en una ventana nueva',
    de: 'In neuem Fenster öffnen'
  },
  restore_option_cancel: {
    ja: 'キャンセル',
    en: 'Cancel',
    'zh-CN': '取消',
    fr: 'Annuler',
    es: 'Cancelar',
    de: 'Abbrechen'
  },
  restore_collection_prompt: {
    ja: 'コレクション「$1」の$2件を復元します。\n\nどの方法で開きますか？',
    en: 'Restore $2 items from collection "$1".\n\nHow would you like to open them?',
    'zh-CN': '要恢复集合"$1"的 $2 个项目。\n\n您想如何打开它们？',
    fr: 'Restaurer $2 éléments de la collection « $1 ».\n\nComment souhaitez-vous les ouvrir ?',
    es: 'Restaurar $2 elementos de la colección "$1".\n\n¿Cómo desea abrirlos?',
    de: '$2 Elemente der Sammlung "$1" wiederherstellen.\n\nWie möchten Sie sie öffnen?'
  },
  position_hint_detail: {
    ja: '；キーで詳細説明',
    en: 'Press ; for details',
    'zh-CN': '按；键查看详情',
    fr: 'Appuyez sur ; pour les détails',
    es: 'Presione ; para detalles',
    de: 'Drücken Sie ; für Details'
  },
  detail_mode_header: {
    ja: '詳細説明',
    en: 'Details',
    'zh-CN': '详细说明',
    fr: 'Détails',
    es: 'Detalles',
    de: 'Details'
  },
  detail_scroll_up: {
    ja: '上スクロール: 履歴を表示',
    en: 'Scroll up: Show history',
    'zh-CN': '向上滚动：显示历史记录',
    fr: 'Défilement vers le haut : Afficher l\'historique',
    es: 'Desplazar hacia arriba: Mostrar historial',
    de: 'Nach oben scrollen: Verlauf anzeigen'
  },
  detail_scroll_down: {
    ja: '下スクロール: ブックマークを表示',
    en: 'Scroll down: Show bookmarks',
    'zh-CN': '向下滚动：显示书签',
    fr: 'Défilement vers le bas : Afficher les signets',
    es: 'Desplazar hacia abajo: Mostrar marcadores',
    de: 'Nach unten scrollen: Lesezeichen anzeigen'
  },
  detail_shift_scroll_up: {
    ja: 'Shift + 上スクロール: 現在のページをお気に入りに追加',
    en: 'Shift + Scroll up: Add current page to favorites',
    'zh-CN': 'Shift + 向上滚动：将当前页面添加到收藏夹',
    fr: 'Maj + Défilement vers le haut : Ajouter la page actuelle aux favoris',
    es: 'Mayús + Desplazar hacia arriba: Añadir página actual a favoritos',
    de: 'Umschalt + Nach oben scrollen: Aktuelle Seite zu Favoriten hinzufügen'
  },
  detail_shift_scroll_down: {
    ja: 'Shift + 下スクロール: お気に入りリストを表示',
    en: 'Shift + Scroll down: Show favorites list',
    'zh-CN': 'Shift + 向下滚动：显示收藏夹列表',
    fr: 'Maj + Défilement vers le bas : Afficher la liste des favoris',
    es: 'Mayús + Desplazar hacia abajo: Mostrar lista de favoritos',
    de: 'Umschalt + Nach unten scrollen: Favoritenliste anzeigen'
  },
  detail_at_key: {
    ja: '@キー: 最近閉じたタブのリストを表示',
    en: '@ key: Show recently closed tabs list',
    'zh-CN': '@键：显示最近关闭的标签页列表',
    fr: 'Touche @ : Afficher la liste des onglets récemment fermés',
    es: 'Tecla @: Mostrar lista de pestañas cerradas recientemente',
    de: '@-Taste: Liste der kürzlich geschlossenen Tabs anzeigen'
  },
  detail_left_area_numeric: {
    ja: '左エリア（黄色）1-9 + キー: 現在のウィンドウのURLを保存（ページのセーブ）',
    en: 'Left area (yellow) 1-9 + key: Save current window URLs (page save)',
    'zh-CN': '左区域（黄色）1-9 + 键：保存当前窗口的URL（页面保存）',
    fr: 'Zone gauche (jaune) 1-9 + touche : Enregistrer les URL de la fenêtre actuelle (sauvegarde de pages)',
    es: 'Área izquierda (amarillo) 1-9 + tecla: Guardar URL de ventana actual (guardar páginas)',
    de: 'Linker Bereich (gelb) 1-9 + Taste: URLs des aktuellen Fensters speichern (Seitenspeicherung)'
  },
  detail_left_area_alpha: {
    ja: '左エリア（黄色）a-z + キー: 現在のウィンドウのタブを保存（タブのセーブ）',
    en: 'Left area (yellow) a-z + key: Save current window tabs (tab save)',
    'zh-CN': '左区域（黄色）a-z + 键：保存当前窗口的标签页（标签页保存）',
    fr: 'Zone gauche (jaune) a-z + touche : Enregistrer les onglets de la fenêtre actuelle (sauvegarde d\'onglets)',
    es: 'Área izquierda (amarillo) a-z + tecla: Guardar pestañas de ventana actual (guardar pestañas)',
    de: 'Linker Bereich (gelb) a-z + Taste: Tabs des aktuellen Fensters speichern (Tab-Speicherung)'
  },
  detail_center_area_numeric: {
    ja: '中央エリア（緑色）1-9 + キー: 保存済みURLリストを表示',
    en: 'Center area (green) 1-9 + key: Show saved URL list',
    'zh-CN': '中央区域（绿色）1-9 + 键：显示已保存的URL列表',
    fr: 'Zone centrale (vert) 1-9 + touche : Afficher la liste des URL enregistrées',
    es: 'Área central (verde) 1-9 + tecla: Mostrar lista de URL guardadas',
    de: 'Mittelbereich (grün) 1-9 + Taste: Gespeicherte URL-Liste anzeigen'
  },
  detail_center_area_alpha: {
    ja: '中央エリア（緑色）a-z + キー: 保存済みタブコレクションを表示',
    en: 'Center area (green) a-z + key: Show saved tab collection',
    'zh-CN': '中央区域（绿色）a-z + 键：显示已保存的标签页集合',
    fr: 'Zone centrale (vert) a-z + touche : Afficher la collection d\'onglets enregistrée',
    es: 'Área central (verde) a-z + tecla: Mostrar colección de pestañas guardadas',
    de: 'Mittelbereich (grün) a-z + Taste: Gespeicherte Tab-Sammlung anzeigen'
  },
  detail_right_area_numeric: {
    ja: '右エリア（青色）1-9 + キー: 保存済みURLリストの全ページを一括で開く',
    en: 'Right area (blue) 1-9 + key: Open all pages from saved URL list',
    'zh-CN': '右区域（蓝色）1-9 + 键：打开已保存URL列表中的所有页面',
    fr: 'Zone droite (bleu) 1-9 + touche : Ouvrir toutes les pages de la liste d\'URL enregistrée',
    es: 'Área derecha (azul) 1-9 + tecla: Abrir todas las páginas de la lista de URL guardadas',
    de: 'Rechter Bereich (blau) 1-9 + Taste: Alle Seiten aus gespeicherter URL-Liste öffnen'
  },
  detail_right_area_alpha: {
    ja: '右エリア（青色）a-z + キー: 保存済みタブコレクションを復元',
    en: 'Right area (blue) a-z + key: Restore saved tab collection',
    'zh-CN': '右区域（蓝色）a-z + 键：恢复已保存的标签页集合',
    fr: 'Zone droite (bleu) a-z + touche : Restaurer la collection d\'onglets enregistrée',
    es: 'Área derecha (azul) a-z + tecla: Restaurar colección de pestañas guardadas',
    de: 'Rechter Bereich (blau) a-z + Taste: Gespeicherte Tab-Sammlung wiederherstellen'
  },
  detail_ctrl_key: {
    ja: 'Ctrlキー: モード切り替え（通常→ステルス→無効→通常）',
    en: 'Ctrl key: Switch mode (Normal → Stealth → Disabled → Normal)',
    'zh-CN': 'Ctrl键：切换模式（正常→隐身→禁用→正常）',
    fr: 'Touche Ctrl : Changer de mode (Normal → Furtif → Désactivé → Normal)',
    es: 'Tecla Ctrl: Cambiar modo (Normal → Sigiloso → Deshabilitado → Normal)',
    de: 'Strg-Taste: Modus wechseln (Normal → Tarnung → Deaktiviert → Normal)'
  },
  detail_toggle_hint: {
    ja: '；キー: 詳細説明を表示/非表示（簡易モードに戻る）',
    en: '; key: Show/hide details (return to simple mode)',
    'zh-CN': '；键：显示/隐藏详细信息（返回简易模式）',
    fr: 'Touche ; : Afficher/masquer les détails (retour au mode simple)',
    es: 'Tecla ;: Mostrar/ocultar detalles (volver al modo simple)',
    de: ';-Taste: Details anzeigen/ausblenden (zurück zum einfachen Modus)'
  },
  simple_scroll_up: {
    ja: '上スクロール: 履歴を表示',
    en: 'Scroll up: Show history',
    'zh-CN': '向上滚动：显示历史记录',
    fr: 'Défilement vers le haut : Afficher l\'historique',
    es: 'Desplazar hacia arriba: Mostrar historial',
    de: 'Nach oben scrollen: Verlauf anzeigen'
  },
  simple_scroll_down: {
    ja: '下スクロール: ブックマークを表示',
    en: 'Scroll down: Show bookmarks',
    'zh-CN': '向下滚动：显示书签',
    fr: 'Défilement vers le bas : Afficher les signets',
    es: 'Desplazar hacia abajo: Mostrar marcadores',
    de: 'Nach unten scrollen: Lesezeichen anzeigen'
  },
  simple_at_key: {
    ja: '@キー: 最近閉じたタブのリストを表示',
    en: '@ key: Show recently closed tabs list',
    'zh-CN': '@键：显示最近关闭的标签页列表',
    fr: 'Touche @ : Afficher la liste des onglets récemment fermés',
    es: 'Tecla @: Mostrar lista de pestañas cerradas recientemente',
    de: '@-Taste: Liste der kürzlich geschlossenen Tabs anzeigen'
  },
  simple_key_section_title: {
    ja: 'キー操作',
    en: 'Key operations',
    'zh-CN': '按键操作',
    fr: 'Opérations de touches',
    es: 'Operaciones de teclas',
    de: 'Tastenoperationen'
  },
  simple_area_left: {
    ja: '左エリア（黄色）',
    en: 'Left area (yellow)',
    'zh-CN': '左区域（黄色）',
    fr: 'Zone gauche (jaune)',
    es: 'Área izquierda (amarillo)',
    de: 'Linker Bereich (gelb)'
  },
  simple_area_center: {
    ja: '中央エリア（緑色）',
    en: 'Center area (green)',
    'zh-CN': '中央区域（绿色）',
    fr: 'Zone centrale (vert)',
    es: 'Área central (verde)',
    de: 'Mittelbereich (grün)'
  },
  simple_area_right: {
    ja: '右エリア（青色）',
    en: 'Right area (blue)',
    'zh-CN': '右区域（蓝色）',
    fr: 'Zone droite (bleu)',
    es: 'Área derecha (azul)',
    de: 'Rechter Bereich (blau)'
  },
  simple_key_numeric_left: {
    ja: '1-9: 現在のウィンドウのURLを保存',
    en: '1-9: Save current window URLs',
    'zh-CN': '1-9：保存当前窗口的URL',
    fr: '1-9 : Enregistrer les URL de la fenêtre actuelle',
    es: '1-9: Guardar URL de ventana actual',
    de: '1-9: URLs des aktuellen Fensters speichern'
  },
  simple_key_alpha_left: {
    ja: 'a-z: 現在のウィンドウのタブを保存',
    en: 'a-z: Save current window tabs',
    'zh-CN': 'a-z：保存当前窗口的标签页',
    fr: 'a-z : Enregistrer les onglets de la fenêtre actuelle',
    es: 'a-z: Guardar pestañas de ventana actual',
    de: 'a-z: Tabs des aktuellen Fensters speichern'
  },
  simple_key_numeric_center: {
    ja: '1-9: 保存済みURLリストを表示',
    en: '1-9: Show saved URL list',
    'zh-CN': '1-9：显示已保存的URL列表',
    fr: '1-9 : Afficher la liste des URL enregistrées',
    es: '1-9: Mostrar lista de URL guardadas',
    de: '1-9: Gespeicherte URL-Liste anzeigen'
  },
  simple_key_alpha_center: {
    ja: 'a-z: 保存済みタブコレクションを表示',
    en: 'a-z: Show saved tab collection',
    'zh-CN': 'a-z：显示已保存的标签页集合',
    fr: 'a-z : Afficher la collection d\'onglets enregistrée',
    es: 'a-z: Mostrar colección de pestañas guardadas',
    de: 'a-z: Gespeicherte Tab-Sammlung anzeigen'
  },
  simple_key_numeric_right: {
    ja: '1-9: 保存済みURLリストの全ページを一括で開く',
    en: '1-9: Open all pages from saved URL list',
    'zh-CN': '1-9：打开已保存URL列表中的所有页面',
    fr: '1-9 : Ouvrir toutes les pages de la liste d\'URL enregistrée',
    es: '1-9: Abrir todas las páginas de la lista de URL guardadas',
    de: '1-9: Alle Seiten aus gespeicherter URL-Liste öffnen'
  },
  simple_key_alpha_right: {
    ja: 'a-z: 保存済みタブコレクションを復元',
    en: 'a-z: Restore saved tab collection',
    'zh-CN': 'a-z：恢复已保存的标签页集合',
    fr: 'a-z : Restaurer la collection d\'onglets enregistrée',
    es: 'a-z: Restaurar colección de pestañas guardadas',
    de: 'a-z: Gespeicherte Tab-Sammlung wiederherstellen'
  },
  common_ok: {
    ja: 'OK',
    en: 'OK',
    'zh-CN': '确定',
    fr: 'OK',
    es: 'Aceptar',
    de: 'OK'
  },
  common_cancel: {
    ja: 'キャンセル',
    en: 'Cancel',
    'zh-CN': '取消',
    fr: 'Annuler',
    es: 'Cancelar',
    de: 'Abbrechen'
  }
};

class GhostInterface {
  constructor() {
    console.log('GhostInterfaceコンストラクタ開始');
    this.isVisible = false;
    this.position = 'right'; // 'left' or 'right'
    this.ghostMarkColor = '#ff0000'; // 赤色（平常時）
    this.ghostMarkHoverColor = '#ffff00'; // 黄色（ホバー時）
    this.isInGhostArea = false; // ゴーストエリア内にいるかのフラグ
    this.currentPercent = 0; // N％値を初期化
    this.ghostMode = 0; // 0: 通常, 1: ステルス, 2: 無効
    this.isDetailMode = false; // 詳細説明モードのフラグ
    this.currentMouseX = 0; // 現在のマウスX座標
    this.currentMouseY = 0; // 現在のマウスY座標
    
    // 新しい状態変数
    this.isPressed = false; // プレス状態
    this.isPointerOutside = false; // ポインターがページ外に出たかどうか
    
    // マウスオーバー自動表示機能
    this.autoOpenOnHover = false; // マウスオーバーで自動表示するか
    this.fixedDisplayType = null; // 固定された表示タイプ（autoOpenOnHoverモードで使用）
    
    // エリア三分割システム用の変数
    this.currentArea = null; // 現在のエリア ('left', 'center', 'right')
    this.keyLists = {}; // 数字キー用のページリスト
    this.collections = {}; // アルファベットキー用のタブコレクション
    this.recentlyClosed = []; // 最近閉じたタブ
    this.recentlyClosedLimit = 25;

    // デバッグ出力の制御フラグ
    this.debugFlags = {
      general: true,
      key: true,
      storage: true,
      position: false,
      pointer: false
    };

    this.lastKeyProcessed = {
      key: null,
      timestamp: 0
    };
    this.activeKey = null;
    
    // スクロール位置追跡
    this.currentDisplayType = null; // 現在表示されているタイプ
    this.lastScrollPercent = 0; // 最後にスクロールした位置
    this.lastScrollType = null; // 最後にスクロールしたタイプ
    
    // お気に入り・履歴関連
    this.favorites = []; // お気に入りリスト
    this.historyLimit = 1000; // 履歴表示数の上限
    
    // フィルタ関連（タイトルとURLの2つ）
    this.filterWords = {
      history: { title: '', url: '' },
      bookmarks: { title: '', url: '' },
      recentlyClosed: { title: '', url: '' }
    };
    
    // 外側クリックハンドラー
    this.outsideClickHandler = null;
    
    console.log('GhostInterfaceコンストラクタ完了');
    this.init();
  }

  async init() {
    console.log('init開始');
    // 設定を読み込み
    const settings = await this.loadSettings();
    this.position = settings.position || 'right';
    const isDark = settings.darkMode === true;
    this.autoOpenOnHover = settings.autoOpenOnHover === true;
    this.applyTheme(isDark);
    console.log('設定読み込み完了, position:', this.position, 'darkMode:', isDark, 'autoOpenOnHover:', this.autoOpenOnHover);
    
    // 保存されたゴーストモードを読み込み
    await this.loadGhostMode();
    
    // お気に入り・履歴データを読み込み
    await this.initializeFeatureData();
    
    // フィルタワードを読み込み
    await this.loadFilterWords();
    
    // ゴーストインターフェースを作成
    this.createGhostInterface();
    
    // ゴーストマークを作成
    this.createGhostMark();
    
    // 位置表示ポップアップを作成
    this.createPositionPopup();
    
    // Gスクロールビューを作成
    this.createGScrollView();
    
    // マウス座標監視を開始
    this.startMouseTracking();
    
    // ホイールイベントリスナーを追加
    this.addWheelListener();
    
    // キーイベントリスナーを追加
    this.addKeyListener();
    
    // ウィンドウリサイズイベントを追加
    this.addResizeListener();
    
    // マウスイベントリスナーを追加
    this.addMouseEventListeners();
    
    // グローバルインスタンスを保存（閉じるボタン用）
    window.ghostInterface = this;
    
    // 初期化完了後に状態を確認・適用
    await this.applyInitialState();
    
    // キー別リストとコレクションを読み込み
    await Promise.all([
      this.loadKeyLists(),
      this.loadCollections()
    ]);
    
    // ストレージ変更を監視
    this.observeStorageChanges();
    
    console.log('init完了');
  }

  debugLog(flag, ...args) {
    if (!this.debugFlags) return;
    if (this.debugFlags[flag]) {
      console.log(...args);
    }
  }

  async loadSettings() {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['position', 'darkMode', 'autoOpenOnHover'], (result) => {
        resolve(result);
      });
    });
  }

  applyTheme(isDark) {
    if (isDark) {
      document.documentElement.setAttribute('data-theme', 'dark');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
  }
  
  // フィルタワードを読み込む（タイトルとURLの2つ）
  async loadFilterWords() {
    return new Promise((resolve) => {
      chrome.storage.sync.get([
        'filterHistoryTitle', 'filterHistoryUrl',
        'filterBookmarksTitle', 'filterBookmarksUrl',
        'filterRecentlyClosedTitle', 'filterRecentlyClosedUrl'
      ], (result) => {
        this.filterWords.history = {
          title: result.filterHistoryTitle || '',
          url: result.filterHistoryUrl || ''
        };
        this.filterWords.bookmarks = {
          title: result.filterBookmarksTitle || '',
          url: result.filterBookmarksUrl || ''
        };
        this.filterWords.recentlyClosed = {
          title: result.filterRecentlyClosedTitle || '',
          url: result.filterRecentlyClosedUrl || ''
        };
        resolve(this.filterWords);
      });
    });
  }
  
  // フィルタワードを保存する（タイトルとURLの2つ）
  async saveFilterWords(type, titleFilter, urlFilter) {
    const keyMap = {
      'history': { title: 'filterHistoryTitle', url: 'filterHistoryUrl' },
      'bookmarks': { title: 'filterBookmarksTitle', url: 'filterBookmarksUrl' },
      'recentlyClosed': { title: 'filterRecentlyClosedTitle', url: 'filterRecentlyClosedUrl' }
    };
    const keys = keyMap[type];
    if (!keys) return Promise.resolve();
    
    this.filterWords[type] = { title: titleFilter, url: urlFilter };
    return new Promise((resolve) => {
      chrome.storage.sync.set({
        [keys.title]: titleFilter,
        [keys.url]: urlFilter
      }, () => {
        resolve();
      });
    });
  }
  
  // フィルタを適用する（タイトルとURLの2つ）
  applyFilter(titleFilter, urlFilter) {
    const type = this.currentDisplayType;
    if (!type || (type !== 'history' && type !== 'bookmarks' && type !== 'recentlyClosed')) {
      console.log('[FILTER] applyFilter: 無効なタイプまたはタイプが設定されていません', type);
      return;
    }
    
    const titleWord = (titleFilter || '').trim();
    const urlWord = (urlFilter || '').trim();
    
    console.log('[FILTER] applyFilter呼び出し:', { type, titleWord, urlWord });
    
    // フィルタワードを保存
    this.saveFilterWords(type, titleWord, urlWord);
    
    // 現在表示中のアイテムを取得してフィルタリング
    const gScrollContent = this.gScrollView?.querySelector('.g-scroll-content');
    if (!gScrollContent) {
      console.log('[FILTER] g-scroll-contentが見つかりません');
      return;
    }
    
    let items = [];
    if (type === 'history') {
      items = Array.from(gScrollContent.querySelectorAll('.history-item'));
    } else if (type === 'bookmarks') {
      items = Array.from(gScrollContent.querySelectorAll('.bookmark-item'));
    } else if (type === 'recentlyClosed') {
      items = Array.from(gScrollContent.querySelectorAll('.recently-closed-item'));
    }
    
    console.log('[FILTER] アイテム数:', items.length, 'type:', type);
    
    // フィルタリング
    let visibleCount = 0;
    items.forEach((item, index) => {
      const title = item.querySelector('.history-title, .bookmark-title, .recently-closed-title')?.textContent || '';
      const url = item.getAttribute('data-url') || '';
      
      // デバッグ用（最初の3個のみ）
      if (index < 3) {
        console.log(`[FILTER] アイテム[${index}]:`, {
          title: title.substring(0, 30),
          url: url.substring(0, 50),
          titleWord: titleWord,
          urlWord: urlWord
        });
      }
      
      const matches = this.matchesFilter(title, url, titleWord, urlWord);
      if (matches) {
        // 表示する場合は、displayをクリア（デフォルトのflexに戻す）
        item.style.removeProperty('display');
      } else {
        // 非表示にする場合は、!importantを使って確実に非表示にする
        item.style.setProperty('display', 'none', 'important');
      }
      if (matches) visibleCount++;
      
      // デバッグ用（最初の3個のみ）
      if (index < 3) {
        console.log(`[FILTER] アイテム[${index}] マッチ結果:`, matches, {
          titleMatch: !titleWord || titleWord === '' || title.toLowerCase().includes(titleWord.toLowerCase()),
          urlMatch: !urlWord || urlWord === '' || url.toLowerCase().includes(urlWord.toLowerCase())
        });
      }
    });
    
    console.log('[FILTER] フィルタ適用完了:', { 
      total: items.length, 
      visible: visibleCount, 
      titleWord: titleWord || '(空)',
      urlWord: urlWord || '(空)'
    });
  }
  
  // フィルタに一致するかチェック（タイトルとURLを別々にチェック）
  matchesFilter(title, url, titleFilter, urlFilter) {
    const titleMatch = !titleFilter || titleFilter === '' || (title || '').toLowerCase().includes(titleFilter.toLowerCase());
    const urlMatch = !urlFilter || urlFilter === '' || (url || '').toLowerCase().includes(urlFilter.toLowerCase());
    
    // 両方のフィルタに一致する必要がある（AND条件）
    return titleMatch && urlMatch;
  }

  // 保存されたゴーストモードを読み込むメソッド
  async loadGhostMode() {
    try {
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({action: 'getGhostMode'}, (response) => {
          if (chrome.runtime.lastError) {
            console.error('ゴーストモード取得エラー:', chrome.runtime.lastError);
            resolve({ mode: 0 });
          } else {
            resolve(response || { mode: 0 });
          }
        });
      });
      
      this.ghostMode = response.mode;
      console.log('保存されたゴーストモードを読み込み:', this.ghostMode);
      
    } catch (error) {
      console.error('ゴーストモード読み込みエラー:', error);
      this.ghostMode = 0; // デフォルト値
    }
  }

  // 初期化完了後に状態を確認・適用するメソッド
  async applyInitialState() {
    console.log('初期状態を適用開始');
    
    try {
      // ゴーストモードの状態を再確認
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({action: 'getGhostMode'}, (response) => {
          if (chrome.runtime.lastError) {
            console.error('初期状態確認エラー:', chrome.runtime.lastError);
            resolve({ mode: this.ghostMode });
          } else {
            resolve(response || { mode: this.ghostMode });
          }
        });
      });
      
      // 最新の状態を取得
      const latestMode = response.mode;
      console.log('最新のゴーストモード:', latestMode, '現在のモード:', this.ghostMode);
      
      // 状態が異なる場合は更新
      if (this.ghostMode !== latestMode) {
        console.log('ゴーストモードを更新:', this.ghostMode, '→', latestMode);
        this.ghostMode = latestMode;
      }
      
      // ゴーストモードを適用（要素が作成された後に実行）
      this.updateGhostMode();
      this.changeGhostMarkColor();
      
      // ゴーストマークの色を強制的に更新
      this.forceUpdateGhostMarkColor();
      
      console.log('初期状態適用完了, モード:', this.ghostMode);
      
    } catch (error) {
      console.error('初期状態適用エラー:', error);
      // エラーが発生した場合でも現在の状態を適用
      this.updateGhostMode();
      this.changeGhostMarkColor();
    }
  }

  // ゴーストマークの色を強制的に更新するメソッド
  forceUpdateGhostMarkColor() {
    if (!this.ghostMark) {
      console.log('ghostMarkが存在しないため、色の更新をスキップ');
      return;
    }
    
    console.log('ゴーストマークの色を強制更新, モード:', this.ghostMode);
    
    // 現在のモードに応じて色を決定
    let finalColor;
    
    if (this.ghostMode === 1) { // ステルス状態
      if (this.isInGhostArea) {
        finalColor = '#ffff00'; // ホバー時は黄色
      } else {
        finalColor = 'transparent'; // 通常時は透明
      }
    } else if (this.ghostMode === 2) { // 無効状態
      finalColor = 'transparent'; // 常に透明
    } else { // 通常状態
      finalColor = this.isInGhostArea ? this.ghostMarkHoverColor : this.ghostMarkColor;
    }
    
    console.log('強制更新 - 最終色:', finalColor, 'モード:', this.ghostMode, 'エリア内:', this.isInGhostArea);
    
    // 色を適用（!importantで上書きするため、個別のborderプロパティを設定）
    this.ghostMark.style.setProperty('border-top-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-right-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-left-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-bottom-color', finalColor, 'important');
    
    // クラスも更新
    this.ghostMark.classList.remove('stealth-mode', 'disabled-mode');
    if (this.ghostMode === 1) {
      this.ghostMark.classList.add('stealth-mode');
    } else if (this.ghostMode === 2) {
      this.ghostMark.classList.add('disabled-mode');
    }
  }

  async initializeFeatureData() {
    console.log('initializeFeatureData開始');
    // お気に入りを読み込み
    this.favorites = await this.getFavorites();
    // 履歴表示数を取得（未設定の場合は最大値）
    this.historyLimit = await this.getHistoryLimit();
    console.log('initializeFeatureData完了:', {
      favoritesCount: this.favorites.length,
      historyLimit: this.historyLimit
    });
    this.updateFavoriteControls();
  }

  async getFavorites() {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['favorites'], (result) => {
        resolve(result.favorites || []);
      });
    });
  }

  async getHistoryLimit() {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['historyLimit'], (result) => {
        // すべての機能を解放 - 常に最大値
        const defaultLimit = result.historyLimit || 1000;
        resolve(defaultLimit);
      });
    });
  }

  createGhostInterface() {
    console.log('createGhostInterface開始');
    const ghostInterface = document.createElement('div');
    ghostInterface.className = `ghost-interface ${this.position}`;
    ghostInterface.id = 'ghost-interface';
    ghostInterface.tabIndex = -1; // キー操作を拾うためフォーカス可能に
    
    // イベントリスナーを追加
    this.addGhostInterfaceEventListeners(ghostInterface);
    
    document.body.appendChild(ghostInterface);
    this.ghostInterface = ghostInterface;
    console.log('ゴーストインターフェース作成完了:', this.ghostInterface);
  }

  createGhostMark() {
    const ghostMark = document.createElement('div');
    ghostMark.className = `ghost-mark ${this.position}`;
    ghostMark.id = 'ghost-mark';
    
    // イベントリスナーを追加
    this.addGhostMarkEventListeners(ghostMark);
    
    document.body.appendChild(ghostMark);
    this.ghostMark = ghostMark;
  }

  createPositionPopup() {
    console.log('createPositionPopup called');
    const positionPopup = document.createElement('div');
    positionPopup.className = `position-popup ${this.position}`;
    positionPopup.id = 'position-popup';
    
    // 簡易モード用の構造
    const simpleContent = document.createElement('div');
    simpleContent.className = 'position-simple';
    simpleContent.innerHTML = `
      <span class="position-text">0%</span>
      <span class="position-hint">${this.getLocalizedText('position_hint_detail')}</span>
    `;
    
    // 詳細モード用の構造
    const detailContent = document.createElement('div');
    detailContent.className = 'position-detail';
    detailContent.style.display = 'none';
    detailContent.innerHTML = `
      <div class="position-header">
        <span class="position-text">0%</span>
        <span class="position-detail-title">${this.getLocalizedText('detail_mode_header')}</span>
      </div>
      <div class="position-content">
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_scroll_up')}</div>
          <div class="detail-item">${this.getLocalizedText('detail_scroll_down')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_shift_scroll_up')}</div>
          <div class="detail-item">${this.getLocalizedText('detail_shift_scroll_down')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_at_key')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_ctrl_key')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_left_area_numeric')}</div>
          <div class="detail-item">${this.getLocalizedText('detail_left_area_alpha')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_center_area_numeric')}</div>
          <div class="detail-item">${this.getLocalizedText('detail_center_area_alpha')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_right_area_numeric')}</div>
          <div class="detail-item">${this.getLocalizedText('detail_right_area_alpha')}</div>
        </div>
        <div class="detail-section">
          <div class="detail-item">${this.getLocalizedText('detail_toggle_hint')}</div>
        </div>
      </div>
    `;
    
    positionPopup.appendChild(simpleContent);
    positionPopup.appendChild(detailContent);
    
    // 詳細モードの時、ポップアップからマウスが離れた時に非表示にする
    positionPopup.addEventListener('mouseleave', (e) => {
      if (this.isDetailMode) {
        // ポップアップからマウスが離れた時、詳細モードをリセット
        this.isDetailMode = false;
        if (this.positionPopup) {
          this.positionPopup.style.display = 'none';
        }
        console.log('ポップアップからマウスが離れました。詳細モードをリセット');
      }
    });
    
    document.body.appendChild(positionPopup);
    this.positionPopup = positionPopup;
    console.log('positionPopup created and assigned:', this.positionPopup);
  }

  createGScrollView() {
    console.log('createGScrollView開始');
    const gScrollView = document.createElement('div');
    gScrollView.className = `g-scroll-view ${this.position}`;
    gScrollView.id = 'g-scroll-view';
    gScrollView.innerHTML = `
      <div class="g-scroll-header">
        <div class="g-scroll-header-top">
          <span class="g-scroll-title">${this.getLocalizedText('bookmarks')}</span>
          <span class="g-scroll-close" id="g-scroll-close">×</span>
        </div>
        <div class="g-scroll-filter-container" style="display: none;">
          <div class="g-scroll-filter-row">
            <label class="g-scroll-filter-label">タイトル:</label>
            <input type="text" class="g-scroll-filter-input" id="g-scroll-filter-title" placeholder="タイトルでフィルタ..." />
            <button class="g-scroll-filter-clear" id="g-scroll-filter-title-clear" style="display: none;">×</button>
            <label class="g-scroll-filter-label">URL:</label>
            <input type="text" class="g-scroll-filter-input" id="g-scroll-filter-url" placeholder="URLでフィルタ..." />
            <button class="g-scroll-filter-clear" id="g-scroll-filter-url-clear" style="display: none;">×</button>
          </div>
        </div>
      </div>
      <div class="g-scroll-content">
        <div id="history-list" style="display: none;"></div>
        <div id="bookmark-list"></div>
        <div id="favorites-list" style="display: none;"></div>
        <div id="recently-closed-list" style="display: none;"></div>
      </div>
    `;
    
    document.body.appendChild(gScrollView);
    this.gScrollView = gScrollView;
    console.log('Gスクロールビュー作成完了:', this.gScrollView);
    
    // Gスクロールビュー自体のホイールイベントを制御
    gScrollView.addEventListener('wheel', (e) => {
      // スクロールビュー全体でのホイールイベントは常に背景への伝播を防ぐ
      e.stopPropagation();
      const gScrollContent = gScrollView.querySelector('.g-scroll-content');
      if (gScrollContent && gScrollContent.contains(e.target)) {
        // スクロールコンテンツ内ではスクロールを許可（stopPropagationは既に呼ばれている）
        return;
      } else {
        // ヘッダーなど他の部分では背景への伝播を完全に防ぐ
        e.preventDefault();
      }
    }, { passive: false });
    
    // Gスクロールビュー内でのスクロール位置追跡
    const gScrollContent = gScrollView.querySelector('.g-scroll-content');
    if (gScrollContent) {
      gScrollContent.addEventListener('scroll', () => {
        this.updateScrollPositionFromScroll();
      });

      gScrollContent.addEventListener('wheel', (e) => {
        // スクロールビュー内でのホイールイベントは常に背景への伝播を防ぐ
        e.stopPropagation();
        
        const { scrollTop, scrollHeight, clientHeight } = gScrollContent;
        if (scrollHeight <= clientHeight) {
          // スクロール不要な場合は背景への伝播を完全に防ぐ
          e.preventDefault();
          return;
        }

        const delta = e.deltaY;
        const atTop = scrollTop <= 0;
        const atBottom = scrollTop + clientHeight >= scrollHeight - 1;

        if ((delta < 0 && atTop) || (delta > 0 && atBottom)) {
          // スクロールの端に到達した場合は背景への伝播を防ぐ
          e.preventDefault();
        }
      }, { passive: false });
    }
    

    
    // 閉じるボタンのイベントリスナーを追加
    const closeButton = gScrollView.querySelector('#g-scroll-close');
    if (closeButton) {
      closeButton.addEventListener('click', () => {
        console.log('閉じるボタンクリック');
        this.hideGScrollView();
      });
    }
    
    // フィルタ入力欄のイベントリスナーを追加（タイトルとURLの2つ）
    const filterTitleInput = gScrollView.querySelector('#g-scroll-filter-title');
    const filterUrlInput = gScrollView.querySelector('#g-scroll-filter-url');
    const filterTitleClear = gScrollView.querySelector('#g-scroll-filter-title-clear');
    const filterUrlClear = gScrollView.querySelector('#g-scroll-filter-url-clear');
    
    const applyFilters = () => {
      const titleFilter = filterTitleInput ? filterTitleInput.value.trim() : '';
      const urlFilter = filterUrlInput ? filterUrlInput.value.trim() : '';
      this.applyFilter(titleFilter, urlFilter);
    };
    
    if (filterTitleInput) {
      filterTitleInput.addEventListener('input', () => {
        applyFilters();
        if (filterTitleClear) {
          filterTitleClear.style.display = filterTitleInput.value.trim() ? 'block' : 'none';
        }
      });
      
      filterTitleInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
        }
        e.stopPropagation();
      });
    }
    
    if (filterUrlInput) {
      filterUrlInput.addEventListener('input', () => {
        applyFilters();
        if (filterUrlClear) {
          filterUrlClear.style.display = filterUrlInput.value.trim() ? 'block' : 'none';
        }
      });
      
      filterUrlInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
        }
        e.stopPropagation();
      });
    }
    
    if (filterTitleClear) {
      filterTitleClear.addEventListener('click', () => {
        if (filterTitleInput) {
          filterTitleInput.value = '';
          filterTitleClear.style.display = 'none';
          applyFilters();
        }
      });
    }
    
    if (filterUrlClear) {
      filterUrlClear.addEventListener('click', () => {
        if (filterUrlInput) {
          filterUrlInput.value = '';
          filterUrlClear.style.display = 'none';
          applyFilters();
        }
      });
    }
    
    // ドラッグ機能は無効化（ユーザー要求により）
    // this.makeDraggable(gScrollView);
  }



  startMouseTracking() {
    // マウス移動イベントを監視
    document.addEventListener('mousemove', (e) => {
      // 現在のマウス位置を保存
      this.currentMouseX = e.clientX;
      this.currentMouseY = e.clientY;
      
      this.checkMousePosition(e.clientX, e.clientY);
    });
  }

  checkMousePosition(mouseX, mouseY) {
    if (!this.ghostInterface) return;
    
    const rect = this.ghostInterface.getBoundingClientRect();
    const isInArea = (
      mouseX >= rect.left &&
      mouseX <= rect.right &&
      mouseY >= rect.top &&
      mouseY <= rect.bottom
    );
    
    // 詳細モードの時は、ポップアップ内にマウスがあるかどうかをチェック
    let isInPopup = false;
    if (this.isDetailMode && this.positionPopup && this.positionPopup.style.display !== 'none') {
      const popupRect = this.positionPopup.getBoundingClientRect();
      isInPopup = (
        mouseX >= popupRect.left &&
        mouseX <= popupRect.right &&
        mouseY >= popupRect.top &&
        mouseY <= popupRect.bottom
      );
    }
    
    // エリアに入った/出た判定（詳細モードでポップアップ内にいる場合は出たと判定しない）
    if (isInArea && !this.isInGhostArea) {
      // updatePositionPopupでcurrentPercentを計算してからenterGhostAreaを呼ぶ
      // （ゴーストインターフェースの左端0%、右端100%として計算）
      this.updatePositionPopup(mouseX, rect);
      this.enterGhostArea();
    } else if (!isInArea && !isInPopup && this.isInGhostArea) {
      this.leaveGhostArea();
    }
    
    // 無効状態でない場合のみ位置ポップアップとエリア判定を更新
    if (isInArea && this.ghostMode !== 2) {
      this.updatePositionPopup(mouseX, rect);
      this.updateCurrentArea(mouseX, rect);
      
      // マウスオーバー自動表示機能が有効で、スクロールビューが開いている場合
      if (this.autoOpenOnHover && this.isVisible && this.fixedDisplayType) {
        // updatePositionPopupで更新されたcurrentPercentを使用してスクロール位置を調整
        this.adjustScrollViewPosition();
      }
    }
    
    // マウス位置を更新（adjustScrollViewPositionで使用）
    this.currentMouseX = mouseX;
    this.currentMouseY = mouseY;
  }
  
  // スクロールビューの位置をマウス位置に応じて調整
  adjustScrollViewPosition() {
    if (!this.gScrollView || !this.isVisible) return;
    
    // updatePositionPopupで計算されたcurrentPercentを使用（ゴーストインターフェースの左端0%、右端100%）
    // ホイールスクロールモードと同じ方法で使用
    const percent = this.currentPercent;
    
    // パーセンテージが変更された場合のみ更新（閾値を小さくしてより敏感に反応）
    // 前回のスクロール位置と比較（lastScrollPercentを使用）
    const lastScrollPercent = this.lastScrollPercent || 0;
    const percentDiff = Math.abs(lastScrollPercent - percent);
    if (percentDiff > 0.1) {
      const oldPercent = lastScrollPercent;
      const items = this.gScrollView.querySelectorAll('.bookmark-item, .history-item, .recently-closed-item, .favorite-item');
      const gScrollContent = this.gScrollView.querySelector('.g-scroll-content');
      if (gScrollContent && items.length > 0) {
        console.log('🎯 [AUTO-OPEN] スクロールビュー位置を調整開始:', {
          oldPercent: oldPercent.toFixed(1) + '%',
          newPercent: percent.toFixed(1) + '%',
          itemsCount: items.length,
          diff: percentDiff.toFixed(2) + '%',
          currentPercent: this.currentPercent,
          scrollContentHeight: gScrollContent.scrollHeight,
          scrollContentClientHeight: gScrollContent.clientHeight,
          currentScrollTop: gScrollContent.scrollTop
        });
        // ホイールスクロールモードと同じ方法でスクロール位置を更新
        this.adjustScrollPosition(percent, items.length);
        // スクロール位置が実際に更新されたか確認（デバッグ用 - 必要に応じてコメントアウト可能）
        // requestAnimationFrame(() => {
        //   const actualScrollTop = gScrollContent.scrollTop;
        //   const maxScrollY = Math.max(0, gScrollContent.scrollHeight - gScrollContent.clientHeight);
        //   const expectedScrollTop = (percent / 100) * maxScrollY;
        //   const scrollDiff = Math.abs(actualScrollTop - expectedScrollTop);
        //   if (scrollDiff > 5) {
        //     console.log('🎯 [AUTO-OPEN] スクロール位置更新確認:', {
        //       expected: expectedScrollTop.toFixed(0),
        //       actual: actualScrollTop.toFixed(0),
        //       diff: scrollDiff.toFixed(0),
        //       maxScrollY: maxScrollY.toFixed(0),
        //       scrollHeight: gScrollContent.scrollHeight.toFixed(0),
        //       clientHeight: gScrollContent.clientHeight.toFixed(0),
        //       percent: percent.toFixed(2) + '%',
        //       isCorrect: false
        //     });
        //   }
        // });
      } else {
        console.log('🎯 [AUTO-OPEN] スクロールビュー位置調整スキップ:', {
          hasGScrollContent: !!gScrollContent,
          itemsCount: items.length
        });
      }
    }
  }
  
  // ポップアップを強制的に更新（キー操作時など）
  forceUpdatePositionPopup() {
    if (!this.ghostInterface || !this.positionPopup) return;
    const rect = this.ghostInterface.getBoundingClientRect();
    this.updatePositionPopup(this.currentMouseX, rect);
  }

  // 現在のエリアを判定・更新するメソッド
  updateCurrentArea(mouseX, rect) {
    const ghostWidth = rect.right - rect.left;
    const relativePosition = mouseX - rect.left;
    const areaWidth = ghostWidth / 3; // エリア幅（1/3ずつ）
    
    let newArea;
    if (relativePosition < areaWidth) {
      newArea = 'left';
    } else if (relativePosition < areaWidth * 2) {
      newArea = 'center';
    } else {
      newArea = 'right';
    }
    
    // エリアが変更された場合のみ処理
    if (this.currentArea !== newArea) {
      this.currentArea = newArea;
      this.updateGhostMarkColorForArea();
      console.log('エリア変更:', newArea);
    }
  }

  // エリアに応じてゴーストマークの色を変更するメソッド
  updateGhostMarkColorForArea() {
    if (!this.ghostMark || this.ghostMode === 2) return; // 無効状態の場合は何もしない
    
    let areaColor;
    switch (this.currentArea) {
      case 'left':
        areaColor = '#ffff00'; // 黄色
        break;
      case 'center':
        areaColor = '#00ff00'; // 緑色
        break;
      case 'right':
        areaColor = '#0000ff'; // 青色
        break;
      default:
        // エリア外の場合は通常の色
        areaColor = this.isInGhostArea ? this.ghostMarkHoverColor : this.ghostMarkColor;
        break;
    }
    
    console.log('エリア色変更:', this.currentArea, areaColor);
    // !importantを設定してCSSを上書き
    this.ghostMark.style.setProperty('border-color', areaColor, 'important');
    if (this.currentArea === 'left') {
      this.ghostMark.style.setProperty('border-top-color', areaColor, 'important');
      this.ghostMark.style.setProperty('border-left-color', areaColor, 'important');
      this.ghostMark.style.setProperty('border-right-color', 'transparent', 'important');
    } else if (this.currentArea === 'center') {
      this.ghostMark.style.setProperty('border-top-color', areaColor, 'important');
      this.ghostMark.style.setProperty('border-left-color', 'transparent', 'important');
      this.ghostMark.style.setProperty('border-right-color', 'transparent', 'important');
    } else if (this.currentArea === 'right') {
      this.ghostMark.style.setProperty('border-top-color', areaColor, 'important');
      this.ghostMark.style.setProperty('border-left-color', 'transparent', 'important');
      this.ghostMark.style.setProperty('border-right-color', areaColor, 'important');
    }
  }

  updatePositionPopup(mouseX, rect) {
    if (!this.positionPopup) {
      this.debugLog('position', 'positionPopupが存在しないためスキップ');
      return;
    }
    
    // 左端を0%、右端を100%として位置を計算
    const ghostWidth = rect.right - rect.left;
    const relativePosition = mouseX - rect.left;
    const percentage = Math.round((relativePosition / ghostWidth) * 100);
    const clampedPercentage = Math.max(0, Math.min(100, percentage));
    // N％値をプロパティに保存
    this.currentPercent = clampedPercentage;
    
    this.debugLog('position', 'Position calculation', {
      mouseX,
      rectLeft: rect.left,
      rectRight: rect.right,
      ghostWidth,
      relativePosition,
      percentage,
      clampedPercentage
    });
    
    // ポップアップの位置を更新（画面端で見切れないように調整）
    // モードに応じた幅を推定
    let estimatedWidth = 200; // 簡易モードのデフォルト幅（CSSでmin-width: 200px）
    let estimatedHeight = 40; // 簡易モードのデフォルト高さ
    
    if (this.isDetailMode) {
      // 詳細モードの幅（CSSで500pxまたは90vw）
      estimatedWidth = Math.min(500, window.innerWidth * 0.9);
      estimatedHeight = Math.min(window.innerHeight * 0.85, 600); // max-height: 85vh
    } else {
      // 簡易モードの幅をより正確に推定（CSSでmin-width: 400px, max-width: 500px）
      estimatedWidth = 450; // 簡易モードの推定幅（各項目が1行で表示できるように広めに設定）
      estimatedHeight = 150; // スクロール操作、キー操作、@キー、ヒントを含む高さ
    }
    
    // 画面幅と高さを取得
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // スクロールビューが表示されている場合は、ポップアップをスクロールビューの左側に配置
    let adjustedLeft = mouseX;
    let adjustedTop = rect.bottom + 5;
    
    if (this.isVisible && this.gScrollView) {
      const scrollViewRect = this.gScrollView.getBoundingClientRect();
      // スクロールビューの左側に配置（スクロールビューの左端から少し左に）
      adjustedLeft = scrollViewRect.left - estimatedWidth / 2 - 10;
      
      // 左端で見切れる場合は、スクロールビューの右側に配置
      if (adjustedLeft < estimatedWidth / 2) {
        adjustedLeft = scrollViewRect.right + estimatedWidth / 2 + 10;
        // 右端で見切れる場合は、画面内に収める
        if (adjustedLeft + estimatedWidth / 2 > viewportWidth) {
          adjustedLeft = viewportWidth - estimatedWidth / 2;
        }
      }
      
      // スクロールビューの上端に合わせる
      adjustedTop = scrollViewRect.top;
    } else {
      // スクロールビューが表示されていない場合は従来の位置計算
      const popupLeft = mouseX - estimatedWidth / 2;
      const popupRight = mouseX + estimatedWidth / 2;
      
      // 右端で見切れる場合
      if (popupRight > viewportWidth) {
        adjustedLeft = viewportWidth - estimatedWidth / 2;
      }
      // 左端で見切れる場合
      if (popupLeft < 0) {
        adjustedLeft = estimatedWidth / 2;
      }
    }
    
    // 下端で見切れる場合（上に表示）
    if (adjustedTop + estimatedHeight > viewportHeight) {
      adjustedTop = rect.top - estimatedHeight - 5;
      // 上にも表示できない場合は画面内に収める
      if (adjustedTop < 0) {
        adjustedTop = 5;
      }
    }
    
    this.positionPopup.style.left = `${adjustedLeft}px`;
    this.positionPopup.style.top = `${adjustedTop}px`;
    
    // ポップアップを表示してから実際の幅を取得し、必要に応じて再調整
    const wasDisplayNone = this.positionPopup.style.display === 'none';
    if (wasDisplayNone) {
      this.positionPopup.style.display = 'block';
    }
    
    // 実際の幅と高さを取得
    const popupRect = this.positionPopup.getBoundingClientRect();
    const actualWidth = popupRect.width;
    const actualHeight = popupRect.height;
    
    // 実際の幅に基づいて再調整
    let finalLeft = adjustedLeft;
    let finalTop = adjustedTop;
    
    // スクロールビューが表示されている場合は、既に調整済みなのでそのまま使用
    if (this.isVisible && this.gScrollView) {
      const scrollViewRect = this.gScrollView.getBoundingClientRect();
      const actualPopupLeft = adjustedLeft - actualWidth / 2;
      
      // 左端で見切れる場合は、スクロールビューの右側に配置
      if (actualPopupLeft < 0) {
        finalLeft = scrollViewRect.right + actualWidth / 2 + 10;
        // 右端で見切れる場合は、画面内に収める
        if (finalLeft + actualWidth / 2 > viewportWidth) {
          finalLeft = viewportWidth - actualWidth / 2;
        }
      }
      
      // スクロールビューの上端に合わせる
      finalTop = scrollViewRect.top;
    } else {
      // スクロールビューが表示されていない場合は従来の調整
      const actualPopupLeft = adjustedLeft - actualWidth / 2;
      const actualPopupRight = adjustedLeft + actualWidth / 2;
      
      // 右端で見切れる場合
      if (actualPopupRight > viewportWidth) {
        finalLeft = viewportWidth - actualWidth / 2;
      }
      // 左端で見切れる場合
      if (actualPopupLeft < 0) {
        finalLeft = actualWidth / 2;
      }
      
      // 下端で見切れる場合（上に表示）
      if (finalTop + actualHeight > viewportHeight) {
        finalTop = rect.top - actualHeight - 5;
        // 上にも表示できない場合は画面内に収める
        if (finalTop < 0) {
          finalTop = 5;
        }
      }
    }
    
    // 最終位置を設定
    if (Math.abs(finalLeft - adjustedLeft) > 1 || Math.abs(finalTop - adjustedTop) > 1) {
      this.positionPopup.style.left = `${finalLeft}px`;
      this.positionPopup.style.top = `${finalTop}px`;
    }
    
    // モードに応じて表示を切り替え
    const simpleContent = this.positionPopup.querySelector('.position-simple');
    const detailContent = this.positionPopup.querySelector('.position-detail');
    
    console.log('updatePositionPopup: モード切り替え', {
      isDetailMode: this.isDetailMode,
      hasSimpleContent: !!simpleContent,
      hasDetailContent: !!detailContent,
      simpleDisplay: simpleContent ? simpleContent.style.display : 'N/A',
      detailDisplay: detailContent ? detailContent.style.display : 'N/A',
      popupClasses: this.positionPopup.className
    });
    
    // パーセンテージを更新（両方のモードで）
    const simpleText = simpleContent ? simpleContent.querySelector('.position-text') : null;
    const detailText = detailContent ? detailContent.querySelector('.position-text') : null;
    if (simpleText) {
      simpleText.textContent = `${clampedPercentage}%`;
    }
    if (detailText) {
      detailText.textContent = `${clampedPercentage}%`;
    }
    
    // 簡易モードの内容を動的に生成
    if (simpleContent && !this.isDetailMode) {
      let areaName = '';
      let numericAction = '';
      let alphaAction = '';
      
      // 現在のエリアに応じた説明を取得
      if (this.currentArea === 'left') {
        areaName = this.getLocalizedText('simple_area_left');
        numericAction = this.getLocalizedText('simple_key_numeric_left');
        alphaAction = this.getLocalizedText('simple_key_alpha_left');
      } else if (this.currentArea === 'center') {
        areaName = this.getLocalizedText('simple_area_center');
        numericAction = this.getLocalizedText('simple_key_numeric_center');
        alphaAction = this.getLocalizedText('simple_key_alpha_center');
      } else if (this.currentArea === 'right') {
        areaName = this.getLocalizedText('simple_area_right');
        numericAction = this.getLocalizedText('simple_key_numeric_right');
        alphaAction = this.getLocalizedText('simple_key_alpha_right');
      }
      
      // 簡易モードのHTMLを生成
      let simpleHTML = `
        <span class="position-text">${clampedPercentage}%</span>
        <div class="simple-scroll-section">
          <div class="simple-item">${this.getLocalizedText('simple_scroll_up')}</div>
          <div class="simple-item">${this.getLocalizedText('simple_scroll_down')}</div>
        </div>
      `;
      
      // エリアが特定されている場合のみキー操作セクションを表示
      if (this.currentArea && areaName) {
        simpleHTML += `
          <div class="simple-key-section">
            <div class="simple-key-title">${this.getLocalizedText('simple_key_section_title')} (${areaName})</div>
            <div class="simple-item">${numericAction}</div>
            <div class="simple-item">${alphaAction}</div>
          </div>
        `;
      }
      
      // @キーの説明を追加
      simpleHTML += `
        <div class="simple-item">${this.getLocalizedText('simple_at_key')}</div>
        <span class="position-hint">${this.getLocalizedText('position_hint_detail')}</span>
      `;
      
      simpleContent.innerHTML = simpleHTML;
    }
    
    // モードに応じてクラスを切り替え（CSSで表示制御）
    if (this.isDetailMode) {
      // 詳細モード
      this.positionPopup.classList.add('detail-mode');
      console.log('detail-modeクラスを追加しました', {
        isDetailMode: this.isDetailMode,
        hasClass: this.positionPopup.classList.contains('detail-mode')
      });
    } else {
      // 簡易モード
      this.positionPopup.classList.remove('detail-mode');
      console.log('detail-modeクラスを削除しました', {
        isDetailMode: this.isDetailMode,
        hasClass: this.positionPopup.classList.contains('detail-mode')
      });
    }
    
    // ポップアップを表示
    this.positionPopup.style.display = 'block';
    this.debugLog('position', 'Position popup display -> block', { isDetailMode: this.isDetailMode });
  }

  toggleDetailMode() {
    this.isDetailMode = !this.isDetailMode;
    console.log('詳細モード切り替え:', this.isDetailMode, {
      isInGhostArea: this.isInGhostArea,
      hasPositionPopup: !!this.positionPopup,
      hasGhostInterface: !!this.ghostInterface
    });
    
    // ポップアップが存在し、ゴーストエリア内にいる場合は更新
    if (this.positionPopup && this.isInGhostArea && this.ghostInterface) {
      // 強制的にポップアップを更新
      this.forceUpdatePositionPopup();
    } else {
      console.log('toggleDetailMode: 更新条件を満たしていません', {
        hasPositionPopup: !!this.positionPopup,
        isInGhostArea: this.isInGhostArea,
        hasGhostInterface: !!this.ghostInterface
      });
    }
  }

  enterGhostArea() {
    this.isInGhostArea = true;
    // 現在のモードに応じて色を変更
    this.changeGhostMarkColor(this.ghostMarkHoverColor);
    
    // フォーカス奪取機能: 現在フォーカスされている要素のフォーカスを解除
    this.blurActiveElement();

    // ゴーストインターフェースにフォーカスを移してキーイベントを確実に拾う
    if (this.ghostInterface && typeof this.ghostInterface.focus === 'function') {
      this.ghostInterface.focus({ preventScroll: true });
      this.debugLog('pointer', 'ghost interface focused for key capture');
    }
    
    // マウスオーバー自動表示機能が有効な場合
    if (this.autoOpenOnHover) {
      // currentPercentは既にupdatePositionPopupで計算されている（ゴーストインターフェースの左端0%、右端100%）
      // そのまま使用する
      
      // スクロールビューが開いていない場合のみ開く
      if (!this.isVisible) {
        // 固定された表示タイプがない場合（初回）はブックマークを開く
        if (!this.fixedDisplayType) {
          console.log('🎯 [AUTO-OPEN] マウスオーバーでブックマークを自動表示, percent:', this.currentPercent.toFixed(1) + '%');
          this.fixedDisplayType = 'bookmarks';
          this.showGScrollView(this.currentPercent, 'bookmarks');
          this.loadHistoryAndBookmarks(this.currentPercent);
        } else {
          // 固定された表示タイプがある場合は、そのタイプで開く
          console.log('🎯 [AUTO-OPEN] マウスオーバーで固定タイプを自動表示:', this.fixedDisplayType, 'percent:', this.currentPercent.toFixed(1) + '%');
          this.showGScrollView(this.currentPercent, this.fixedDisplayType);
          if (this.fixedDisplayType === 'bookmarks') {
            this.loadHistoryAndBookmarks(this.currentPercent);
          } else if (this.fixedDisplayType === 'history') {
            this.loadHistory(this.currentPercent);
          } else if (this.fixedDisplayType === 'recentlyClosed') {
            this.displayRecentlyClosed(this.currentPercent);
          }
        }
      }
      // 既に開いている場合は、マウス位置に応じてスクロールビューの位置を調整（checkMousePositionで行う）
    }
    
    console.log('ゴーストエリアに入りました');
  }

  // 現在フォーカスされている要素のフォーカスを解除するメソッド
  blurActiveElement() {
    const activeElement = document.activeElement;
    if (activeElement && activeElement !== document.body && activeElement !== document.documentElement) {
      console.log('フォーカスを解除:', activeElement.tagName, activeElement.type || '');
      activeElement.blur();
      
      // 入力フィールドの場合は、さらに強制的にフォーカスを解除
      if (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true') {
        // 少し遅延させてから再度フォーカスを解除（確実にするため）
        setTimeout(() => {
          if (document.activeElement === activeElement) {
            activeElement.blur();
          }
        }, 10);
      }
    }
  }

  leaveGhostArea() {
    this.isInGhostArea = false;
    // 現在のモードに応じて色を変更
    this.changeGhostMarkColor(this.ghostMarkColor);
    
    // マウスオーバー自動表示機能が有効な場合でも、スクロールビューは開いたままにする
    // （元々の実装通り、ゴーストエリアから離れてもスクロールビューは閉じない）
    
    // 詳細モードの時は、ポップアップを非表示にしない（ポップアップ内でマウス操作を可能にするため）
    if (!this.isDetailMode) {
      // 詳細モードをリセット
      this.isDetailMode = false;
    
    // ポップアップを非表示
    if (this.positionPopup) {
      this.positionPopup.style.display = 'none';
      }
    }

    this.lastKeyProcessed = { key: null, timestamp: 0 };
    this.activeKey = null;
    
    console.log('ゴーストエリアを出ました', { isDetailMode: this.isDetailMode });
  }

  // ゴーストモードを更新するメソッド
  updateGhostMode() {
    console.log('updateGhostMode開始, ghostMode:', this.ghostMode);
    if (!this.ghostMark) {
      console.log('ghostMarkが見つかりません');
      return;
    }
    
    // 既存のモードクラスを削除
    this.ghostMark.classList.remove('stealth-mode', 'disabled-mode');
    console.log('既存のモードクラスを削除しました');
    
    // 新しいモードクラスを追加
    switch (this.ghostMode) {
      case 0: // 通常状態
        console.log('通常状態に変更');
        this.changeGhostMarkColor(this.ghostMarkColor);
        break;
      case 1: // ステルス状態
        console.log('ステルス状態に変更');
        this.ghostMark.classList.add('stealth-mode');
        this.changeGhostMarkColor('transparent');
        console.log('stealth-modeクラスを追加しました');
        break;
      case 2: // 無効状態
        console.log('無効状態に変更');
        this.ghostMark.classList.add('disabled-mode');
        this.changeGhostMarkColor('transparent');
        console.log('disabled-modeクラスを追加しました');
        break;
    }
    
    console.log('現在のghostMarkクラス:', this.ghostMark.className);
    
    // 強制的に色を更新（確実に反映させるため）
    setTimeout(() => {
      this.forceUpdateGhostMarkColor();
    }, 0);
  }

  // ゴーストマークの色を変更するメソッド（条件分岐付き）
  changeGhostMarkColor(color) {
    if (!this.ghostMark) {
      console.log('ghostMarkが存在しないため、色の変更をスキップ');
      return;
    }
    
    // エリアが設定されている場合は、エリア色を優先
    if (this.currentArea && this.isInGhostArea && this.ghostMode !== 2) {
      this.updateGhostMarkColorForArea();
      return;
    }
    
    // 現在のモードに応じて色を決定
    let finalColor = color;
    
    if (this.ghostMode === 1) { // ステルス状態
      if (this.isInGhostArea) {
        finalColor = '#ffff00'; // ホバー時は黄色
      } else {
        finalColor = 'transparent'; // 通常時は透明
      }
    } else if (this.ghostMode === 2) { // 無効状態
      finalColor = 'transparent'; // 常に透明
    } else { // 通常状態
      finalColor = color; // 指定された色を使用
    }
    
    console.log('changeGhostMarkColor:', {
      requestedColor: color,
      finalColor: finalColor,
      ghostMode: this.ghostMode,
      isInGhostArea: this.isInGhostArea,
      currentArea: this.currentArea
    });
    
    // 色を適用（!importantで上書きするため、個別のborderプロパティを設定）
    this.ghostMark.style.setProperty('border-top-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-right-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-left-color', finalColor, 'important');
    this.ghostMark.style.setProperty('border-bottom-color', finalColor, 'important');
    
    // 確実に反映させるため、少し遅延してから再度適用
    setTimeout(() => {
      if (this.ghostMark) {
        this.ghostMark.style.setProperty('border-top-color', finalColor, 'important');
        this.ghostMark.style.setProperty('border-right-color', finalColor, 'important');
        this.ghostMark.style.setProperty('border-left-color', finalColor, 'important');
        this.ghostMark.style.setProperty('border-bottom-color', finalColor, 'important');
        console.log('色の再適用完了:', finalColor);
      }
    }, 10);
  }

  // マウス位置がゴーストインターフェース領域内かチェックするメソッド
  isMouseInGhostArea(mouseX, mouseY) {
    if (!this.ghostInterface) {
      console.log('ghostInterfaceが見つかりません');
      return false;
    }
    
    const rect = this.ghostInterface.getBoundingClientRect();
    const isInArea = mouseX >= rect.left && mouseX <= rect.right && 
                     mouseY >= rect.top && mouseY <= rect.bottom;
    
    this.debugLog('pointer', 'マウス位置チェック', {
      mouseX, mouseY,
      rectLeft: rect.left, rectRight: rect.right,
      rectTop: rect.top, rectBottom: rect.bottom,
      isInArea
    });
    
    return isInArea;
  }

  addResizeListener() {
    window.addEventListener('resize', () => {
      // ウィンドウサイズが変更されたときにゴーストインターフェースとゴーストマークのサイズを更新
      this.updateSizes();
    });
  }

  // マウスイベントリスナーを追加
  addMouseEventListeners() {
    // mousedown: プレス時にインターフェースを非表示
    document.addEventListener('mousedown', (e) => {
      // ゴーストインターフェースまたはゴーストマーク上でのイベントは個別に処理
      if (e.target === this.ghostInterface || e.target === this.ghostMark) {
        return;
      }
      
      if (this.isInGhostArea && !this.isPressed && !this.isVisible) {
        console.log('ゴーストエリアでプレス検出');
        this.isPressed = true;
        this.hideGhostInterface();
      }
    });

    // mouseup: リリース時にインターフェースを再表示
    document.addEventListener('mouseup', (e) => {
      if (this.isPressed) {
        console.log('プレスリリース検出');
        this.isPressed = false;
        this.showGhostInterface();
      }
    });

    // mouseleave: ポインターがページ外に出た時にインターフェースを再表示
    document.addEventListener('mouseleave', (e) => {
      if (this.isPressed) {
        console.log('ポインターがページ外に出ました');
        this.isPressed = false;
        this.isPointerOutside = true;
        this.showGhostInterface();
      }
    });

    // mouseenter: ポインターがページ内に入った時にフラグをリセット
    document.addEventListener('mouseenter', (e) => {
      this.isPointerOutside = false;
    });
  }

  // ゴーストインターフェースを非表示にする
  hideGhostInterface() {
    if (this.ghostInterface && this.ghostMark) {
      console.log('ゴーストインターフェースを非表示にします');
      this.ghostInterface.style.opacity = '0';
      this.ghostMark.style.opacity = '0';
      
      // バブリング方式に変更したため、simulatePressEventは不要
      // イベントはaddGhostInterfaceEventListenersで直接バブリングされる
    }
  }

  // ゴーストインターフェースを表示する
  showGhostInterface() {
    if (this.ghostInterface && this.ghostMark) {
      console.log('ゴーストインターフェースを表示します');
      this.ghostInterface.style.opacity = '1';
      this.ghostMark.style.opacity = '1';
    }
  }

  // 背景要素にイベントをバブリングする
  bubbleEventToBackground(originalEvent, eventType) {
    const mouseX = this.currentMouseX;
    const mouseY = this.currentMouseY;
    
    console.log(`背景要素に${eventType}イベントをバブリング:`, { mouseX, mouseY });
    
    // 一時的にゴーストインターフェースをpointer-events: noneにする
    const originalGhostInterfacePointerEvents = this.ghostInterface.style.pointerEvents;
    const originalGhostMarkPointerEvents = this.ghostMark.style.pointerEvents;
    
    this.ghostInterface.style.pointerEvents = 'none';
    this.ghostMark.style.pointerEvents = 'none';
    
    // マウス位置の要素を取得
    const elementAtPoint = document.elementFromPoint(mouseX, mouseY);
    
    // pointer-eventsを元に戻す
    this.ghostInterface.style.pointerEvents = originalGhostInterfacePointerEvents;
    this.ghostMark.style.pointerEvents = originalGhostMarkPointerEvents;
    
    if (elementAtPoint) {
      console.log('バブリング対象の要素:', elementAtPoint);
      
      // ゴーストインターフェースやゴーストマークの場合は処理しない
      if (elementAtPoint === this.ghostInterface || elementAtPoint === this.ghostMark) {
        console.log('ゴースト要素のため、バブリングをスキップします');
        return;
      }
      
      // イベントオプションを作成
      const eventOptions = {
        bubbles: true,
        cancelable: true,
        view: window,
        detail: originalEvent.detail || 1,
        screenX: mouseX,
        screenY: mouseY,
        clientX: mouseX,
        clientY: mouseY,
        ctrlKey: originalEvent.ctrlKey || false,
        altKey: originalEvent.altKey || false,
        shiftKey: originalEvent.shiftKey || false,
        metaKey: originalEvent.metaKey || false,
        button: originalEvent.button || 0,
        relatedTarget: originalEvent.relatedTarget || null
      };
      
      // 新しいイベントを作成して発火
      const newEvent = new MouseEvent(eventType, eventOptions);
      elementAtPoint.dispatchEvent(newEvent);
      console.log(`${eventType}イベントを背景要素にバブリングしました`);
      
      // 親要素にもイベントを伝達（より確実にするため）
      let parent = elementAtPoint.parentElement;
      let depth = 0;
      while (parent && depth < 3) { // 最大3階層まで
        try {
          const parentEvent = new MouseEvent(eventType, eventOptions);
          parent.dispatchEvent(parentEvent);
          console.log(`${eventType}イベントを親要素にバブリング:`, parent.tagName, parent.className);
          parent = parent.parentElement;
          depth++;
        } catch (error) {
          console.log('親要素へのイベント伝達でエラー:', error);
          break;
        }
      }
      
      // さらに、document.bodyにもイベントを発火（最後の手段）
      try {
        const bodyEvent = new MouseEvent(eventType, eventOptions);
        document.body.dispatchEvent(bodyEvent);
        console.log(`${eventType}イベントをdocument.bodyにバブリングしました`);
      } catch (error) {
        console.log('document.bodyへのイベント伝達でエラー:', error);
      }
      
      // クリック可能な要素を探して強制的にクリック
      if (eventType === 'click') {
        this.findAndClickClickableElement(elementAtPoint, mouseX, mouseY);
      }
      
    } else {
      console.log('マウス位置に要素が見つかりません');
    }
  }

  // クリック可能な要素を探して強制的にクリック
  findAndClickClickableElement(targetElement, mouseX, mouseY) {
    console.log('クリック可能な要素を探索中...');
    
    // 対象要素から親要素を辿ってクリック可能な要素を探す
    let currentElement = targetElement;
    let depth = 0;
    const maxDepth = 5;
    
    while (currentElement && depth < maxDepth) {
      // クリック可能かどうかをチェック
      const isClickable = this.isElementClickable(currentElement);
      
      if (isClickable) {
        console.log('クリック可能な要素を発見:', currentElement.tagName, currentElement.className);
        
        // 強制的にクリック
        try {
          currentElement.click();
          console.log('要素を強制クリックしました');
          return;
        } catch (error) {
          console.log('強制クリックでエラー:', error);
        }
      }
      
      currentElement = currentElement.parentElement;
      depth++;
    }
    
    console.log('クリック可能な要素が見つかりませんでした');
  }
  
  // 要素がクリック可能かどうかを判定
  isElementClickable(element) {
    // タグ名で判定
    const clickableTags = ['A', 'BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'LABEL'];
    if (clickableTags.includes(element.tagName)) {
      return true;
    }
    
    // イベントリスナーの存在をチェック
    const hasClickHandler = element.onclick || 
                           element.getAttribute('onclick') ||
                           element.querySelector('[onclick]');
    
    if (hasClickHandler) {
      return true;
    }
    
    // カーソルスタイルで判定
    const computedStyle = window.getComputedStyle(element);
    const cursor = computedStyle.cursor;
    if (cursor === 'pointer') {
      return true;
    }
    
    // 特定のクラス名で判定
    const clickableClasses = ['clickable', 'button', 'link', 'nav', 'menu', 'dropdown'];
    const className = element.className.toLowerCase();
    if (clickableClasses.some(cls => className.includes(cls))) {
      return true;
    }
    
    return false;
  }

  // 同じ地点にプレスイベントを強制的に発生させる（従来の方法）
  simulatePressEvent() {
    // 現在のマウス位置を取得
    const mouseX = this.currentMouseX;
    const mouseY = this.currentMouseY;
    
    console.log('プレスイベントをシミュレート:', { mouseX, mouseY });
    
    // 一時的にゴーストインターフェースをpointer-events: noneにする
    const originalGhostInterfacePointerEvents = this.ghostInterface.style.pointerEvents;
    const originalGhostMarkPointerEvents = this.ghostMark.style.pointerEvents;
    
    this.ghostInterface.style.pointerEvents = 'none';
    this.ghostMark.style.pointerEvents = 'none';
    
    // マウス位置の要素を取得
    const elementAtPoint = document.elementFromPoint(mouseX, mouseY);
    
    // pointer-eventsを元に戻す
    this.ghostInterface.style.pointerEvents = originalGhostInterfacePointerEvents;
    this.ghostMark.style.pointerEvents = originalGhostMarkPointerEvents;
    
    if (elementAtPoint) {
      console.log('プレス対象の要素:', elementAtPoint);
      
      // ゴーストインターフェースやゴーストマークの場合は処理しない
      if (elementAtPoint === this.ghostInterface || elementAtPoint === this.ghostMark) {
        console.log('ゴースト要素のため、プレスイベントをスキップします');
        return;
      }
      
      // 完全なイベントシーケンスをシミュレート
      const eventOptions = {
        bubbles: true,
        cancelable: true,
        view: window,
        detail: 1,
        screenX: mouseX,
        screenY: mouseY,
        clientX: mouseX,
        clientY: mouseY,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: null
      };
      
      // mousedown → mouseup → click の順序で発火
      const mousedownEvent = new MouseEvent('mousedown', eventOptions);
      const mouseupEvent = new MouseEvent('mouseup', eventOptions);
      const clickEvent = new MouseEvent('click', eventOptions);
      
      // イベントを順序通りに発火
      elementAtPoint.dispatchEvent(mousedownEvent);
      setTimeout(() => {
        elementAtPoint.dispatchEvent(mouseupEvent);
        setTimeout(() => {
          elementAtPoint.dispatchEvent(clickEvent);
          console.log('完全なイベントシーケンスを発火しました');
        }, 10);
      }, 10);
      
      console.log('プレスイベントを発火しました');
    } else {
      console.log('マウス位置に要素が見つかりません');
    }
  }

  // ゴーストインターフェースのイベントリスナーを追加
  // 注意: pointer-events: none にしているため、この要素に直接イベントリスナーを追加しても動作しません
  // ホイールイベントは document レベルで監視し、ゴーストエリア内かどうかを判定してから処理します
  // マウスイベント（クリック、ドラッグなど）は自動的に背景に透過されます
  addGhostInterfaceEventListeners(element) {
    // pointer-events: none にしているため、この要素に直接イベントリスナーを追加しても動作しません
    // イベントは自動的に背景に透過されます
    // ホイールイベントは document レベルで監視しています（startWheelTracking メソッド）
  }

  // ゴーストマークのイベントリスナーを追加
  // 注意: pointer-events: none にしているため、この要素に直接イベントリスナーを追加しても動作しません
  // ホイールイベントは document レベルで監視し、ゴーストエリア内かどうかを判定してから処理します
  // マウスイベント（クリック、ドラッグなど）は自動的に背景に透過されます
  addGhostMarkEventListeners(element) {
    // pointer-events: none にしているため、この要素に直接イベントリスナーを追加しても動作しません
    // イベントは自動的に背景に透過されます
    // ホイールイベントは document レベルで監視しています（startWheelTracking メソッド）
  }

  updateSizes() {
    // ゴーストインターフェースとゴーストマークのサイズを動的に更新
    const width = window.innerWidth * 0.25; // 25vw
    const height = 20; // 20px
    
    if (this.ghostInterface) {
      this.ghostInterface.style.width = `${width}px`;
      this.ghostInterface.style.height = `${height}px`;
    }
    
    if (this.ghostMark) {
      this.ghostMark.style.width = `${width}px`;
      this.ghostMark.style.height = `${height}px`;
    }
  }

  makeDraggable(element) {
    const header = element.querySelector('.g-scroll-header');
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;

    header.addEventListener('mousedown', (e) => {
      isDragging = true;
      initialX = e.clientX - element.offsetLeft;
      initialY = e.clientY - element.offsetTop;
    });

    document.addEventListener('mousemove', (e) => {
      if (isDragging) {
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        
        element.style.left = currentX + 'px';
        element.style.top = currentY + 'px';
        element.style.right = 'auto';
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
  }

  // ホイールイベントを処理するメソッド
  handleWheelEvent(e) {
    // 無効状態の場合は何もしない
    if (this.ghostMode === 2) return;
    
    // プレス状態の場合は何もしない
    if (this.isPressed) return;
    
    // ゴーストインターフェースが非表示の場合は何もしない
    if (this.ghostInterface && this.ghostInterface.style.opacity === '0') return;
    
    // ゴーストエリア内にいるかをチェック
    // pointer-events: none にしているため、e.target がゴーストインターフェースになることはない
    if (!this.isInGhostArea) return;
    
    const isShiftPressed = e.shiftKey;
    const isDownScroll = e.deltaY > 0;
    const isUpScroll = e.deltaY < 0;
    
    console.log('ホイールイベント処理:', {
      isShiftPressed,
      isDownScroll,
      isUpScroll,
      currentPercent: this.currentPercent,
      lastScrollPercent: this.lastScrollPercent,
      lastScrollType: this.lastScrollType
    });
    
    if (isShiftPressed) {
      // シフトキーが押されている場合
      if (isDownScroll) {
        // シフト + 下ホイールスクロール: お気に入りリスト表示
          console.log('シフト + 下ホイールスクロール: お気に入りリスト表示');
          const currentType = this.getCurrentDisplayType();
          if (currentType !== 'favorites') {
            this.showFavoritesView();
          } else {
            // 同じタイプで新しい位置の場合、スクロール位置を更新
            if (this.lastScrollPercent !== this.currentPercent || this.lastScrollType !== 'favorites') {
              console.log('同じタイプで新しい位置のため、スクロール位置を更新');
              this.updateScrollPositionForCurrentType('favorites');
            } else {
              console.log('お気に入りは既に表示されているため、何もしません');
            }
        }
      } else if (isUpScroll) {
        // シフト + 上ホイールスクロール: 現在のページをお気に入りに追加
          console.log('シフト + 上ホイールスクロール: 現在のページをお気に入りに追加');
          this.addCurrentPageToFavorites();
      }
    } else {
      // 通常のホイールスクロール
      const currentType = this.getCurrentDisplayType();
      
      console.log('現在の表示タイプ:', currentType);
      
      if (isDownScroll) {
        // 下ホイールスクロール: ブックマーク表示
        console.log('下ホイールスクロール検出, currentType:', currentType, '!== bookmarks:', currentType !== 'bookmarks');
        if (currentType !== 'bookmarks') {
          console.log('下ホイールスクロール: ブックマーク表示');
          this.showGScrollView(this.currentPercent, 'bookmarks');
          this.loadHistoryAndBookmarks(this.currentPercent);
        } else {
          // 同じタイプで新しい位置の場合、スクロール位置を更新
          if (this.lastScrollPercent !== this.currentPercent || this.lastScrollType !== 'bookmarks') {
            console.log('同じタイプで新しい位置のため、スクロール位置を更新');
            this.updateScrollPositionForCurrentType('bookmarks');
          } else {
            console.log('ブックマークは既に表示されているため、何もしません');
          }
        }
      } else if (isUpScroll) {
        // 上ホイールスクロール: 履歴表示
        console.log('上ホイールスクロール検出, currentType:', currentType, '!== history:', currentType !== 'history');
        
        // マウスオーバー自動表示機能が有効な場合
        if (this.autoOpenOnHover && this.fixedDisplayType) {
          if (this.fixedDisplayType !== 'history') {
            console.log('🎯 [AUTO-OPEN] 上ホイールスクロール: 履歴に切り替え');
            this.fixedDisplayType = 'history';
            this.showGScrollView(this.currentPercent, 'history');
            this.loadHistory(this.currentPercent);
          } else {
            // 同じタイプで新しい位置の場合、スクロール位置を更新
            if (this.lastScrollPercent !== this.currentPercent || this.lastScrollType !== 'history') {
              console.log('同じタイプで新しい位置のため、スクロール位置を更新');
              this.updateScrollPositionForCurrentType('history');
            }
          }
        } else {
          // 従来の動作
          if (currentType !== 'history') {
            console.log('上ホイールスクロール: 履歴表示');
            this.showGScrollView(this.currentPercent, 'history');
            this.loadHistory(this.currentPercent);
          } else {
            // 同じタイプで新しい位置の場合、スクロール位置を更新
            if (this.lastScrollPercent !== this.currentPercent || this.lastScrollType !== 'history') {
              console.log('同じタイプで新しい位置のため、スクロール位置を更新');
              this.updateScrollPositionForCurrentType('history');
            } else {
              console.log('履歴は既に表示されているため、何もしません');
            }
          }
        }
      }
    }
  }

  addWheelListener() {
    // capture phaseでイベントをキャッチして、早期にpreventDefault()を実行
    document.addEventListener('wheel', (e) => {
      // Gスクロールビュー上でのホイールイベントを制御
      const isOnGScrollView = this.gScrollView && this.gScrollView.contains(e.target);
      if (isOnGScrollView) {
        // Gスクロールビュー内のすべてのホイールイベントで背景への伝播を防ぐ
        e.stopPropagation();
        const gScrollContent = this.gScrollView.querySelector('.g-scroll-content');
        if (gScrollContent && gScrollContent.contains(e.target)) {
          // スクロールコンテンツ内では、スクロール可能な場合は許可
          // ただし、stopPropagationは既に呼ばれているので背景には伝わらない
          return;
        } else {
          // ヘッダーなど他の部分では背景への伝播を完全に防ぐ
          e.preventDefault();
          return;
        }
      }
      
      // ゴーストエリア内でのホイールイベントを処理
      // pointer-events: none にしているため、e.target がゴーストインターフェースになることはない
      // そのため、isInGhostArea のみで判定する
      if (!this.isInGhostArea) return;
      
      // 無効状態の場合は何もしない
      if (this.ghostMode === 2) return;
      
      // プレス状態の場合は何もしない
      if (this.isPressed) return;
      
      // ゴーストインターフェースが非表示の場合は何もしない
      if (this.ghostInterface && this.ghostInterface.style.opacity === '0') return;
      
      // ホイールイベントを処理して背景への伝達を遮断
      // preventDefault()を呼ぶことで、ページのスクロールを防ぐ
      e.preventDefault();
      e.stopPropagation();
      
      this.handleWheelEvent(e);
    }, { capture: true, passive: false });
  }

  addKeyListener() {
    const keyHandler = (e) => {
      // 現在のマウス位置を使用
      const isInGhostArea = this.isMouseInGhostArea(this.currentMouseX, this.currentMouseY);
      if (e.repeat) {
        console.log('[GHOST][KEY] keydown event ignored (repeat)', {
          key: e.key,
          isInGhostArea,
          currentArea: this.currentArea
        });
        return;
      }
      if (this.activeKey && this.activeKey === e.key) {
        console.log('[GHOST][KEY] keydown event ignored (awaiting keyup)', { key: e.key });
        return;
      }
      const now = Date.now();
      
      // ゴーストエリア内での；キー処理（詳細モード切り替え）- 他のキー処理より先にチェック
      if (isInGhostArea && (e.key === ';' || e.key === '；')) {
        // 重複処理を防ぐ
        if (this.lastKeyProcessed && this.lastKeyProcessed.key === e.key && (now - this.lastKeyProcessed.timestamp) < 400) {
          console.log('[GHOST][KEY] ; key ignored (throttled)', {
            key: e.key,
            delta: now - this.lastKeyProcessed.timestamp
          });
          return;
        }
        e.preventDefault();
        this.toggleDetailMode();
        this.lastKeyProcessed = { key: e.key, timestamp: now };
        this.activeKey = e.key;
        return;
      }
      
      if (this.lastKeyProcessed && this.lastKeyProcessed.key === e.key && (now - this.lastKeyProcessed.timestamp) < 400) {
        console.log('[GHOST][KEY] keydown event ignored (throttled)', {
          key: e.key,
          delta: now - this.lastKeyProcessed.timestamp
        });
        return;
      }
      console.log('[GHOST][KEY] keydown event', {
        key: e.key,
        isInGhostArea,
        currentArea: this.currentArea,
        mouseX: this.currentMouseX,
        mouseY: this.currentMouseY,
        ghostVisible: this.isVisible
      });
      
      console.log('キーイベント検出:', {
        key: e.key,
        ctrlKey: e.ctrlKey,
        clientX: e.clientX,
        clientY: e.clientY,
        isInGhostArea: isInGhostArea,
        currentArea: this.currentArea
      });
      
      // ゴーストエリア内でのコントロールキー処理
      if (isInGhostArea && e.key === 'Control') {
        console.log('コントロールキー押下検出（ゴーストエリア内）');
        e.preventDefault(); // ブラウザのデフォルト動作を防ぐ
        const newMode = (this.ghostMode + 1) % 3;
        this.updateGhostModeGlobally(newMode);
      } else if (!isInGhostArea && e.key === 'Control') {
        console.log('コントロールキー押下検出（ゴーストエリア外）');
      }
      
      // ゴーストエリア内でのキー入力処理
      if (isInGhostArea && this.currentArea && e.key !== 'Control' && e.key !== ';' && e.key !== '；') {
        e.preventDefault(); // ブラウザのデフォルト動作を防ぐ
        this.handleKeyInput(e.key);
        this.activeKey = e.key;
        this.lastKeyProcessed = { key: e.key, timestamp: now };
      }
    };

    document.addEventListener('keydown', keyHandler, { capture: true });
    window.addEventListener('keydown', keyHandler, { capture: true });
    this.keydownHandler = keyHandler;

    const keyupHandler = (e) => {
      if (this.activeKey && this.activeKey === e.key) {
        console.log('[GHOST][KEY] keyup reset', e.key);
        this.activeKey = null;
      }
    };
    document.addEventListener('keyup', keyupHandler, { capture: true });
    window.addEventListener('keyup', keyupHandler, { capture: true });
    this.keyupHandler = keyupHandler;
  }

  // キー入力処理メソッド
  handleKeyInput(key) {
    console.log('キー入力処理:', key, 'エリア:', this.currentArea);
    
    // シフトキーは単独では処理しない（スクロール時の組み合わせで使用されるため）
    if (key === 'Shift') {
      console.log('[GHOST][KEY] Shift key ignored (used with scroll)');
      return;
    }
    
    // @キーは全エリアで処理可能
    if (key === '@') {
      console.log('[GHOST][KEY] @ key (all areas)');
      
      // マウスオーバー自動表示機能が有効な場合
      if (this.autoOpenOnHover && this.fixedDisplayType) {
        if (this.fixedDisplayType !== 'recentlyClosed') {
          console.log('🎯 [AUTO-OPEN] @キー: 最近閉じたタブに切り替え');
          this.fixedDisplayType = 'recentlyClosed';
          this.displayRecentlyClosed(this.currentPercent);
          return;
        } else {
          // 既に最近閉じたタブが表示されている場合は何もしない
          return;
        }
      }
      
      // 従来の動作
      this.displayRecentlyClosed(this.currentPercent);
      return;
    }
    
    switch (this.currentArea) {
      case 'left':
        console.log('[GHOST][KEY] left area key', key);
        // 左エリア: ページ保存機能
        this.handleLeftAreaKey(key);
        break;
      case 'center':
        console.log('[GHOST][KEY] center area key', key);
        // 中央エリア: リスト表示機能
        this.handleCenterAreaKey(key);
        break;
      case 'right':
        console.log('[GHOST][KEY] right area key', key);
        // 右エリア: 一括開封機能
        this.handleRightAreaKey(key);
        break;
      default:
        console.log('[GHOST][KEY] no area / ignored', key);
        break;
    }
  }

  // 左エリアのキー処理（ページ保存）
  handleLeftAreaKey(key) {
    if (this.isDigitKey(key)) {
      console.log('[GHOST][SAVE] page slot key (collection mode)', key);
      this.saveCurrentWindowAsCollection(key);
    } else if (this.isLetterKey(key)) {
      const normalizedKey = this.normalizeLetterKey(key);
      console.log('[GHOST][SAVE] collection key', normalizedKey);
      this.saveCurrentWindowAsCollection(normalizedKey);
    } else {
      console.log('[GHOST][SAVE] unsupported key', key);
      this.showNotification(this.getLocalizedText('notification_unsupported_key'), 'warning');
    }
  }

  // 中央エリアのキー処理（リスト表示）
  handleCenterAreaKey(key) {
    if (this.isDigitKey(key)) {
      console.log('[GHOST][VIEW] center area digit key', key);
      if (this.collections[key] && this.collections[key].tabs && this.collections[key].tabs.length > 0) {
        this.displayCollection(key);
      } else {
        this.displayKeyList(key); // 互換性のため
      }
    } else if (this.isLetterKey(key)) {
      const normalizedKey = this.normalizeLetterKey(key);
      console.log('[GHOST][VIEW] center area letter key', normalizedKey);
      this.displayCollection(normalizedKey);
    } else {
      console.log('[GHOST][VIEW] center area unsupported key', key);
      this.showNotification(this.getLocalizedText('notification_unsupported_key'), 'warning');
    }
  }

  // キー別リストを表示するメソッド
  displayKeyList(key) {
    const keyList = this.getKeyList(key);
    
    if (keyList.length === 0) {
      console.log('キーリストが空です:', key);
      this.showEmptyKeyListMessage(key);
      return;
    }
    
    console.log('キーリストを表示:', key, keyList.length, '件');
    this.showGScrollView(this.currentPercent, 'keylist');
    this.renderKeyList(key, keyList);
  }

  // キーリストの内容をレンダリングするメソッド
  renderKeyList(key, keyList) {
    const gScrollView = document.querySelector('.g-scroll-view');
    if (!gScrollView) return;
    
    // ヘッダータイトルを更新
    const header = gScrollView.querySelector('.g-scroll-header');
    if (header) {
      const titleElement = header.querySelector('.g-scroll-title');
      if (titleElement) {
        titleElement.textContent = `キー "${key}" のリスト (${keyList.length}件)`;
      }
    }
    
    // コンテンツを非表示にする
    const historyList = document.getElementById('history-list');
    const bookmarkList = document.getElementById('bookmark-list');
    const favoritesList = document.getElementById('favorites-list');
    
    if (historyList) historyList.style.display = 'none';
    if (bookmarkList) bookmarkList.style.display = 'none';
    if (favoritesList) favoritesList.style.display = 'none';
    
    // キーリスト用のコンテナを作成または取得
    let keyListContainer = document.getElementById('keylist-list');
    if (!keyListContainer) {
      keyListContainer = document.createElement('div');
      keyListContainer.id = 'keylist-list';
      keyListContainer.style.display = 'block';
      gScrollView.querySelector('.g-scroll-content').appendChild(keyListContainer);
    }
    
    keyListContainer.style.display = 'block';
    keyListContainer.innerHTML = '';
    
    // キーリストのアイテムを表示
    keyList.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'keylist-item';
      
      div.innerHTML = `
        <div class="keylist-content">
          <img src="${item.icon}" class="keylist-favicon" alt="favicon" onerror="this.style.display='none'">
          <div class="keylist-title">${item.title}</div>
          <button class="remove-keylist-button" style="background: none; border: none; cursor: pointer; font-size: 16px; color: #ff4444; margin-left: 5px;">×</button>
        </div>
      `;
      
      // 削除ボタンのクリックイベント
      const removeButton = div.querySelector('.remove-keylist-button');
      if (removeButton) {
        removeButton.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('キーリストアイテム削除ボタンクリック:', item.title);
          
          // 削除前のリスト長を取得
          const keyList = this.getKeyList(key);
          const beforeLength = keyList.length;
          
          this.removePageFromKeyList(key, item.url);
          
          // 削除後のリスト長をチェック
          const afterLength = this.getKeyList(key).length;
          
          if (afterLength > 0) {
            // リストにまだアイテムがある場合は再表示
            this.displayKeyList(key);
          } else {
            // リストが空になった場合は自動で閉じる（handleEmptyKeyListで処理）
            console.log('リストが空になったため、表示を閉じます');
          }
        });
      }
      div.addEventListener('click', () => window.open(item.url, '_blank'));
      keyListContainer.appendChild(div);
    });
    
    // スクロール位置を調整
    this.adjustScrollPosition(this.currentPercent, keyList.length);
  }

  // 空のキーリストメッセージを表示するメソッド
  showEmptyKeyListMessage(key) {
    this.showNotification(
      `キー "${key}" のリストは空です`,
      'warning',
      {
        title: 'リスト情報',
        duration: 4000
      }
    );
  }

  // キーリストが空になった場合の処理
  handleEmptyKeyList(key) {
    console.log('=== handleEmptyKeyListデバッグ開始 ===');
    console.log('空になったキー:', key);
    
    // 現在の表示タイプを確認
    const currentType = this.getCurrentDisplayType();
    console.log('現在の表示タイプ:', currentType);
    
    // Gスクロールビューの表示状態を確認
    const gScrollView = document.querySelector('.g-scroll-view');
    console.log('Gスクロールビューの存在:', !!gScrollView);
    if (gScrollView) {
      console.log('Gスクロールビューのdisplay:', gScrollView.style.display);
      console.log('Gスクロールビューのopacity:', gScrollView.style.opacity);
    }
    
    // キーリストコンテナの状態を確認
    const keyListContainer = document.getElementById('keylist-list');
    console.log('キーリストコンテナの存在:', !!keyListContainer);
    if (keyListContainer) {
      console.log('キーリストコンテナのdisplay:', keyListContainer.style.display);
    }
    
    // 現在キーリストが表示されている場合は閉じる
    if (currentType === 'keylist') {
      console.log('⚠️ キーリスト表示中なので閉じます');
      this.hideGScrollView();
      console.log('✅ キーリスト表示を閉じました');
    } else {
      console.log('❓ キーリスト表示中ではありません。現在のタイプ:', currentType);
    }
    
    // 空リストメッセージを表示
    console.log('空リストメッセージを表示します');
    this.showEmptyKeyListMessage(key);
    console.log('=== handleEmptyKeyListデバッグ終了 ===');
  }

  // 右エリアのキー処理（一括開封）
  async handleRightAreaKey(key) {
    if (this.isDigitKey(key)) {
      console.log('[GHOST][RESTORE] right area digit key', key);
      if (this.collections[key] && this.collections[key].tabs && this.collections[key].tabs.length > 0) {
        await this.confirmAndRestoreCollection(key);
      } else {
        await this.confirmAndOpenPages(key); // レガシーデータ用
      }
    } else if (this.isLetterKey(key)) {
      const normalizedKey = this.normalizeLetterKey(key);
      console.log('[GHOST][RESTORE] right area letter key', normalizedKey);
      await this.confirmAndRestoreCollection(normalizedKey);
    } else {
      console.log('[GHOST][RESTORE] right area unsupported key', key);
      this.showNotification(this.getLocalizedText('notification_unsupported_key'), 'warning');
    }
  }

  // キーリスト内の全ページを一括で開くメソッド
  openAllPagesInKeyList(key) {
    const keyList = this.getKeyList(key);
    
    if (keyList.length === 0) {
      console.log('キーリストが空です:', key);
      this.showEmptyKeyListMessage(key);
      return;
    }
    
    console.log('キーリストの全ページを開封:', key, keyList.length, '件');
    
    // 各ページを新しいタブで開く
    keyList.forEach((item, index) => {
      setTimeout(() => {
        window.open(item.url, '_blank');
        console.log('ページを開封:', item.title, item.url);
      }, index * 100); // 100ms間隔で開く（ブラウザの負荷を軽減）
    });
    
    // フィードバックを表示
    this.showBulkOpenFeedback(key, keyList.length);
  }

  // 一括開封のフィードバックを表示するメソッド
  showBulkOpenFeedback(key, count) {
    const message = `キー "${key}" の ${count}件を開封中...\n新しいタブで順次開かれます`;
    this.showNotification(message, 'info', {
      title: '一括開封',
      duration: 3200
    });
  }

  // ゴーストモードを全ページで共有するメソッド
  async updateGhostModeGlobally(newMode) {
    try {
      console.log('ゴーストモードを全ページで更新:', newMode);
      
      // backgroundにゴーストモード変更を送信
      const response = await new Promise((resolve) => {
        chrome.runtime.sendMessage({
          action: 'updateGhostMode',
          mode: newMode
        }, (response) => {
          if (chrome.runtime.lastError) {
            console.error('ゴーストモード更新エラー:', chrome.runtime.lastError);
            resolve({ success: false });
          } else {
            resolve(response || { success: false });
          }
        });
      });
      
      if (response.success) {
        // ローカルのゴーストモードを更新
        this.ghostMode = newMode;
        this.updateGhostMode();
        this.changeGhostMarkColor();
        console.log('ゴーストモード更新完了:', newMode);
      } else {
        console.error('ゴーストモード更新に失敗しました');
      }
    } catch (error) {
      console.error('ゴーストモード更新エラー:', error);
    }
  }

  // 他のタブからのゴーストモード変更通知を受け取るメソッド
  handleGhostModeChange(newMode) {
    console.log('他のタブからゴーストモード変更通知:', newMode);
    
    // ローカルのゴーストモードを更新
    this.ghostMode = newMode;
    this.updateGhostMode();
    this.changeGhostMarkColor();
    
    // 確実に反映させるため、強制更新も実行
    setTimeout(() => {
      this.forceUpdateGhostMarkColor();
    }, 50);
    
    console.log('ゴーストモード同期完了:', newMode);
  }



  // お気に入り関連UIの更新
  updateFavoriteControls() {
    const favoriteButtons = document.querySelectorAll('.favorite-button');
    favoriteButtons.forEach(button => {
      button.style.display = 'inline';
    });
    
    const addCurrentPageButton = document.getElementById('add-current-page-favorite');
    if (addCurrentPageButton) {
        addCurrentPageButton.style.display = 'inline';
        const currentUrl = window.location.href;
        const isCurrentPageFavorite = this.favorites.some(fav => fav.url === currentUrl);
        addCurrentPageButton.textContent = isCurrentPageFavorite ? '★' : '☆';
        addCurrentPageButton.style.color = isCurrentPageFavorite ? '#FFD700' : '#ccc';
    }
    
    console.log('お気に入りUI更新完了:', {
      favoriteButtonsCount: favoriteButtons.length
    });
  }

  async loadHistory(percent) {
    console.log('loadHistory呼び出し, percent:', percent, 'historyLimit:', this.historyLimit);
    const history = await this.getHistory();
    console.log('取得した履歴数:', history.length);
    
    // background.jsで既に制限されているため、そのまま使用
    this.displayHistory(history, percent);
  }

  async loadHistoryAndBookmarks(percent) {
    // 履歴を取得
    const history = await this.getHistory();
    const bookmarks = await this.getBookmarks();
    
    // ブックマークのみ表示
    this.displayBookmarks(bookmarks, percent);
  }

  async getHistory() {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({
        action: 'getHistory',
        maxResults: this.historyLimit
      }, (response) => {
        console.log('getHistory response:', response ? response.length : 0, '件 (要求:', this.historyLimit, '件)');
        
        // Chromeの履歴APIの制限について説明
        if (response && response.length < this.historyLimit) {
          console.log('注意: Chromeの履歴APIは最大約1000件まで取得可能です。実際の取得件数:', response.length);
        }
        
        resolve(response || []);
      });
    });
  }

  async getBookmarks() {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({action: 'getBookmarks'}, (response) => {
        resolve(response || []);
      });
    });
  }

  async getRecentlyClosed() {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({
        action: 'getRecentlyClosed',
        maxResults: this.recentlyClosedLimit
      }, (response) => {
        if (chrome.runtime.lastError) {
          const errorMessage = chrome.runtime.lastError.message || 'unknown';
          console.error('[GHOST][RECENT] message error:', errorMessage);
          resolve({ success: false, error: errorMessage });
          return;
        }
        resolve(response || { success: true, items: [] });
      });
    });
  }

  displayHistory(history, percent = 0) {
    console.log('displayHistory呼び出し, percent:', percent, 'history数:', history.length);
    const historyList = document.getElementById('history-list');
    if (!historyList) {
      console.log('history-list要素が見つかりません');
      return;
    }
    
    historyList.innerHTML = '';
    
    // 全履歴を表示
    history.forEach(item => {
      const div = document.createElement('div');
      div.className = 'history-item';
      
      // ファビコンのURLを生成
      const faviconUrl = this.getFaviconUrl(item.url);
      
      div.setAttribute('data-url', item.url);
      div.innerHTML = `
        <div class="history-content">
          <img src="${faviconUrl}" class="history-favicon" alt="favicon" onerror="this.style.display='none'">
          <div class="history-title">${item.title}</div>
        </div>
      `;
      div.addEventListener('click', () => window.open(item.url, '_blank'));
      historyList.appendChild(div);
    });
    
    // フィルタを適用
    const filters = this.filterWords.history || { title: '', url: '' };
    this.applyFilter(filters.title, filters.url);
    
    // N％位置に応じてスクロール位置を調整
    this.adjustScrollPosition(percent, history.length);
  }

  async displayBookmarks(bookmarks, percent = 0) {
    console.log('displayBookmarks呼び出し, percent:', percent, 'bookmarks数:', bookmarks.length);
    
    // ダークモード状態と色情報をログ出力
    const isDark = await new Promise((resolve) => {
      chrome.storage.sync.get(['darkMode'], (result) => {
        resolve(result.darkMode === true || document.documentElement.getAttribute('data-theme') === 'dark');
      });
    });
    // 最初の5個のブックマークのデータをログ出力
    if (bookmarks.length > 0) {
      const sampleData = bookmarks.slice(0, 5).map((item, idx) => ({
        index: idx,
        title: item.title,
        url: item.url,
        titleType: typeof item.title,
        titleLength: item.title ? item.title.length : 0,
        titleIsEmpty: !item.title || item.title.trim() === '',
        hasUrl: !!item.url
      }));
      console.log('最初の5個のブックマークデータ（詳細）:');
      sampleData.forEach(data => {
        console.log(`  [${data.index}] title: "${data.title}" (type: ${data.titleType}, length: ${data.titleLength}, empty: ${data.titleIsEmpty}), url: ${data.url}`);
      });
    }
    const bookmarkList = document.getElementById('bookmark-list');
    if (!bookmarkList) {
      console.log('bookmark-list要素が見つかりません');
      return;
    }
    
    // スクロールビューの実際の幅を取得して、動的にmin-widthを計算
    const gScrollView = this.gScrollView;
    let calculatedMinWidth = 50; // デフォルト値（最小値）
    let availableWidth = 400; // デフォルト値（計算に使用）
    
    if (gScrollView) {
      const scrollViewRect = gScrollView.getBoundingClientRect();
      const scrollViewWidth = scrollViewRect.width || gScrollView.offsetWidth;
      
      // 利用可能な幅を計算
      // .g-scroll-content の padding: 12px（左右で24px）
      // .bookmark-item の padding: 4px 8px（左右で16px）
      // .bookmark-favicon の幅: 14px
      // gap: 6px（favicon-title間とtitle-button間で12px）
      // .favorite-button の幅: 20px（min-width）
      const contentPadding = 24; // 左右12pxずつ
      const itemPadding = 16; // 左右8pxずつ
      const faviconWidth = 14;
      const gapTotal = 12; // 6px × 2
      const buttonWidth = 20;
      
      availableWidth = scrollViewWidth - contentPadding - itemPadding - faviconWidth - gapTotal - buttonWidth;
      
      // 利用可能幅の85%を最小幅として設定（適切な表示を確保）
      calculatedMinWidth = Math.max(50, Math.floor(availableWidth * 0.85));
      
      console.log('min-width計算:', {
        scrollViewWidth: scrollViewWidth,
        availableWidth: availableWidth,
        calculatedMinWidth: calculatedMinWidth,
        buttonSpace: buttonWidth + 6 // ボタン幅 + gap
      });
    }
    
    bookmarkList.innerHTML = '';
    
    // 全ブックマークを表示
    let emptyTitleCount = 0;
    bookmarks.forEach((item, index) => {
      // タイトルが空の場合のログ（最初の10個のみ）
      if (!item.title || item.title.trim() === '') {
        emptyTitleCount++;
        if (index < 10) {
          console.log(`ブックマーク[${index}] タイトルが空:`, {
            title: item.title,
            url: item.url,
            hasTitle: !!item.title,
            titleValue: item.title,
            titleType: typeof item.title
          });
        }
      }
      const div = document.createElement('div');
      div.className = 'bookmark-item';
      div.setAttribute('data-url', item.url || '');
      
      // ファビコンのURLを生成
      const faviconUrl = this.getFaviconUrl(item.url);
      
      // お気に入り状態を確認
      const isFavorite = this.favorites.some(fav => fav.url === item.url);
      const favoriteIcon = isFavorite ? '★' : '☆';
      
      // タイトルが空の場合はURLを使用
      const displayTitle = (item.title && item.title.trim()) ? item.title.trim() : (item.url || '無題');
      
      // 最初の5個について、表示前のデータをログ出力
      if (index < 5) {
        console.log(`ブックマーク[${index}] 表示データ:`, {
          originalTitle: item.title,
          displayTitle: displayTitle,
          url: item.url,
          escapedTitle: this.escapeHtml(displayTitle)
        });
      }
      
      div.innerHTML = `
        <div class="bookmark-content">
          <img src="${faviconUrl}" class="bookmark-favicon" alt="favicon" onerror="this.style.display='none'">
          <div class="bookmark-title">${this.escapeHtml(displayTitle)}</div>
          <button class="favorite-button" style="color: ${isFavorite ? '#FFD700' : '#ccc'};" title="${isFavorite ? 'お気に入りから削除' : 'お気に入りに追加'}">${favoriteIcon}</button>
        </div>
      `;
      
      // 親要素にもスタイルを設定（色はCSS変数に任せる）
      const contentElement = div.querySelector('.bookmark-content');
      if (contentElement) {
        // colorはCSS変数に任せる（ダークモード対応のため）
        contentElement.style.setProperty('opacity', '1', 'important');
        contentElement.style.setProperty('visibility', 'visible', 'important');
        contentElement.style.setProperty('display', 'flex', 'important');
      }
      
      // お気に入りボタンを取得（スタイル設定とイベントリスナーで使用）
      const favoriteButton = div.querySelector('.favorite-button');
      if (favoriteButton) {
        // スタイルを設定（確実に表示されるように）
        favoriteButton.style.setProperty('flex-shrink', '0', 'important');
        favoriteButton.style.setProperty('margin-left', 'auto', 'important');
        favoriteButton.style.setProperty('display', 'inline-block', 'important');
        favoriteButton.style.setProperty('visibility', 'visible', 'important');
        favoriteButton.style.setProperty('opacity', '1', 'important');
        favoriteButton.style.setProperty('min-width', '20px', 'important');
        favoriteButton.style.setProperty('width', 'auto', 'important');
        
        // クリックイベントを設定
        favoriteButton.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggleFavorite(item);
          // ボタンの表示を更新
          const isNowFavorite = this.favorites.some(fav => fav.url === item.url);
          favoriteButton.textContent = isNowFavorite ? '★' : '☆';
          favoriteButton.style.color = isNowFavorite ? '#FFD700' : '#ccc';
        });
      }
      
      // タイトル要素に直接インラインスタイルを設定して、外部CSSの影響を完全に防ぐ
      const titleElement = div.querySelector('.bookmark-title');
      if (titleElement) {
        // colorはCSS変数に任せる（ダークモード対応のため）
        titleElement.style.setProperty('opacity', '1', 'important');
        titleElement.style.setProperty('visibility', 'visible', 'important');
        titleElement.style.setProperty('display', 'block', 'important');
        titleElement.style.setProperty('font-size', '13px', 'important');
        titleElement.style.setProperty('font-weight', 'bold', 'important');
        titleElement.style.setProperty('text-align', 'left', 'important');
        titleElement.style.setProperty('line-height', '1.4', 'important');
        titleElement.style.setProperty('overflow', 'hidden', 'important');
        titleElement.style.setProperty('text-overflow', 'ellipsis', 'important');
        titleElement.style.setProperty('white-space', 'nowrap', 'important');
        titleElement.style.setProperty('flex', '1 1 0%', 'important');
        titleElement.style.setProperty('flex-shrink', '1', 'important');
        titleElement.style.setProperty('flex-grow', '1', 'important');
        titleElement.style.setProperty('min-width', `${calculatedMinWidth}px`, 'important');
        titleElement.style.setProperty('width', 'auto', 'important');
        // ボタンのスペース（20px + gap 6px = 26px）を確保するため、max-widthを設定
        const maxTitleWidth = availableWidth - 26; // ボタンとgapのスペースを確保
        titleElement.style.setProperty('max-width', `${maxTitleWidth}px`, 'important');
        titleElement.style.setProperty('position', 'relative', 'important');
        titleElement.style.setProperty('z-index', '1', 'important');
        titleElement.style.setProperty('box-sizing', 'border-box', 'important');
      }
      
      // bookmark-itemにもスタイルを設定（色はCSS変数に任せる）
      // colorはCSS変数に任せる（ダークモード対応のため）
      div.style.setProperty('opacity', '1', 'important');
      div.style.setProperty('visibility', 'visible', 'important');
      div.style.setProperty('display', 'flex', 'important');
      
      // 最初の5個について、DOMに追加後の内容を確認
      if (index < 5) {
        if (titleElement) {
          // DOMに追加した後に計算済みスタイルを確認
          setTimeout(() => {
            const computed = window.getComputedStyle(titleElement);
            const contentComputed = contentElement ? window.getComputedStyle(contentElement) : null;
            const itemComputed = window.getComputedStyle(div);
            
            console.log(`ブックマーク[${index}] 計算済みスタイル確認（詳細）:`);
            console.log(`  タイトル要素:`, {
              textContent: titleElement.textContent,
              color: computed.color,
              opacity: computed.opacity,
              visibility: computed.visibility,
              display: computed.display,
              fontSize: computed.fontSize,
              fontWeight: computed.fontWeight,
              width: computed.width,
              height: computed.height,
              lineHeight: computed.lineHeight,
              position: computed.position,
              zIndex: computed.zIndex,
              transform: computed.transform,
              clip: computed.clip,
              clipPath: computed.clipPath
            });
            if (contentComputed) {
              console.log(`  コンテンツ要素:`, {
                color: contentComputed.color,
                opacity: contentComputed.opacity,
                visibility: contentComputed.visibility,
                display: contentComputed.display,
                width: contentComputed.width,
                height: contentComputed.height,
                overflow: contentComputed.overflow,
                position: contentComputed.position
              });
            }
            console.log(`  アイテム要素:`, {
              color: itemComputed.color,
              opacity: itemComputed.opacity,
              visibility: itemComputed.visibility,
              display: itemComputed.display,
              width: itemComputed.width,
              height: itemComputed.height,
              overflow: itemComputed.overflow,
              position: itemComputed.position
            });
            
            // 実際に要素が表示されているか確認
            const rect = titleElement.getBoundingClientRect();
            console.log(`  タイトル要素の位置情報:`, {
              top: rect.top,
              left: rect.left,
              width: rect.width,
              height: rect.height,
              visible: rect.width > 0 && rect.height > 0
            });
          }, 0);
        }
      }
      
      div.addEventListener('click', () => window.open(item.url, '_blank'));
      bookmarkList.appendChild(div);
    });
    
    if (emptyTitleCount > 0) {
      console.log(`タイトルが空のブックマーク: ${emptyTitleCount}個 / 全${bookmarks.length}個`);
    }
    
    // DOMに追加後、最初の5個のタイトル要素の実際の内容を確認し、スタイルを再適用
    setTimeout(() => {
      const titleElements = bookmarkList.querySelectorAll('.bookmark-title');
      console.log('DOM追加後のタイトル要素確認（最初の5個）:');
      for (let i = 0; i < Math.min(5, titleElements.length); i++) {
        const el = titleElements[i];
        const computed = window.getComputedStyle(el);
        console.log(`  [${i}] textContent: "${el.textContent}", color: ${computed.color}, opacity: ${computed.opacity}, visibility: ${computed.visibility}, display: ${computed.display}`);
        
        // スタイルが上書きされている場合は再適用（colorはCSS変数に任せる）
        if (computed.opacity === '0' || computed.visibility === 'hidden' || 
            computed.display === 'none') {
          console.log(`  [${i}] スタイルが上書きされているため再適用します`);
          // colorはCSS変数に任せる（ダークモード対応のため）
          el.style.setProperty('opacity', '1', 'important');
          el.style.setProperty('visibility', 'visible', 'important');
          el.style.setProperty('display', 'block', 'important');
        }
      }
      
      // すべてのタイトル要素と親要素に対してスタイルを強制的に再適用
      titleElements.forEach((el, idx) => {
        // colorはCSS変数に任せる（ダークモード対応のため）
        el.style.setProperty('opacity', '1', 'important');
        el.style.setProperty('visibility', 'visible', 'important');
        el.style.setProperty('display', 'block', 'important');
        el.style.setProperty('font-size', '13px', 'important');
        el.style.setProperty('font-weight', 'bold', 'important');
        // 動的に計算されたmin-widthを使用
        el.style.setProperty('flex', '1 1 0%', 'important');
        el.style.setProperty('flex-shrink', '1', 'important');
        el.style.setProperty('flex-grow', '1', 'important');
        el.style.setProperty('min-width', `${calculatedMinWidth}px`, 'important');
        el.style.setProperty('width', 'auto', 'important');
        // ボタンのスペース（20px + gap 6px = 26px）を確保するため、max-widthを設定
        const maxTitleWidth = availableWidth - 26; // ボタンとgapのスペースを確保
        el.style.setProperty('max-width', `${maxTitleWidth}px`, 'important');
        el.style.setProperty('box-sizing', 'border-box', 'important');
        
        // 親要素も修正
        const contentParent = el.closest('.bookmark-content');
        if (contentParent) {
          // colorはCSS変数に任せる（ダークモード対応のため）
          contentParent.style.setProperty('opacity', '1', 'important');
          contentParent.style.setProperty('visibility', 'visible', 'important');
          contentParent.style.setProperty('display', 'flex', 'important');
          contentParent.style.setProperty('align-items', 'center', 'important');
          contentParent.style.setProperty('min-width', '0', 'important');
          contentParent.style.setProperty('width', '100%', 'important');
          contentParent.style.setProperty('box-sizing', 'border-box', 'important');
        }
        
        // ★ボタンも修正
        const favoriteButton = el.closest('.bookmark-item')?.querySelector('.favorite-button');
        if (favoriteButton) {
          favoriteButton.style.setProperty('flex-shrink', '0', 'important');
          favoriteButton.style.setProperty('margin-left', 'auto', 'important');
        }
        
        const itemParent = el.closest('.bookmark-item');
        if (itemParent) {
          // フィルタで非表示にされているアイテムはdisplayを設定しない
          const computedDisplay = window.getComputedStyle(itemParent).display;
          if (computedDisplay !== 'none') {
            // colorはCSS変数に任せる（ダークモード対応のため）
            itemParent.style.setProperty('opacity', '1', 'important');
            itemParent.style.setProperty('visibility', 'visible', 'important');
            itemParent.style.setProperty('display', 'flex', 'important');
            itemParent.style.setProperty('box-sizing', 'border-box', 'important');
          }
        }
      });
      
      // 色情報をログ出力（DOM要素が確実に存在する時点で）
      requestAnimationFrame(() => {
        const bookmarkList = document.getElementById('bookmark-list');
        if (bookmarkList) {
          const firstBookmark = bookmarkList.querySelector('.bookmark-item');
          const firstTitle = firstBookmark?.querySelector('.bookmark-title');
          const firstContent = firstBookmark?.querySelector('.bookmark-content');
          
          if (firstBookmark && firstTitle) {
            const bookmarkStyle = getComputedStyle(firstBookmark);
            const titleStyle = getComputedStyle(firstTitle);
            const contentStyle = firstContent ? getComputedStyle(firstContent) : null;
            const rootStyle = getComputedStyle(document.documentElement);
            
            console.log('🎨 [COLOR] displayBookmarks - 実際の色情報:', {
              isDark: isDark,
              dataTheme: document.documentElement.getAttribute('data-theme'),
              cssVariables: {
                '--ghost-scroll-foreground': rootStyle.getPropertyValue('--ghost-scroll-foreground').trim() || '未設定',
                '--ghost-scroll-item-text': rootStyle.getPropertyValue('--ghost-scroll-item-text').trim() || '未設定',
              },
              actualColors: {
                bookmarkItem: {
                  background: bookmarkStyle.backgroundColor,
                  color: bookmarkStyle.color,
                },
                bookmarkContent: {
                  background: contentStyle?.backgroundColor || 'N/A',
                  color: contentStyle?.color || 'N/A',
                },
                bookmarkTitle: {
                  color: titleStyle.color,
                  fontWeight: titleStyle.fontWeight,
                },
              },
              firstBookmarkText: firstTitle.textContent?.substring(0, 30) || 'N/A',
            });
          }
        }
      });
      
      // フィルタを適用（DOM要素が確実に存在する時点で）
      // requestAnimationFrameを使って、DOM要素が完全にレンダリングされた後にフィルタを適用
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // フィルタ入力欄から直接値を取得（保存された値ではなく、現在の入力値を優先）
          const filterTitleInput = this.gScrollView?.querySelector('#g-scroll-filter-title');
          const filterUrlInput = this.gScrollView?.querySelector('#g-scroll-filter-url');
          
          console.log('[FILTER] displayBookmarks: フィルタ入力欄の存在確認', {
            filterTitleInput: !!filterTitleInput,
            filterUrlInput: !!filterUrlInput,
            gScrollView: !!this.gScrollView
          });
          
          const titleFilter = filterTitleInput ? filterTitleInput.value.trim() : '';
          const urlFilter = filterUrlInput ? filterUrlInput.value.trim() : '';
          
          // 入力欄に値がない場合は、保存された値を使用
          const savedFilters = this.filterWords.bookmarks || { title: '', url: '' };
          const finalTitleFilter = titleFilter || savedFilters.title || '';
          const finalUrlFilter = urlFilter || savedFilters.url || '';
          
          console.log('[FILTER] displayBookmarks: フィルタを適用', { 
            titleFilter: titleFilter || '(空)',
            urlFilter: urlFilter || '(空)',
            savedFilters: { title: savedFilters.title || '(空)', url: savedFilters.url || '(空)' },
            finalTitleFilter: finalTitleFilter || '(空)',
            finalUrlFilter: finalUrlFilter || '(空)',
            currentDisplayType: this.currentDisplayType 
          });
          this.applyFilter(finalTitleFilter, finalUrlFilter);
        });
      });
    }, 100);
    
    // N％位置に応じてスクロール位置を調整
    this.adjustScrollPosition(percent, bookmarks.length);
  }

  async displayRecentlyClosed(percent = 0) {
    try {
      const response = await this.getRecentlyClosed();
      console.log('[GHOST][RECENT] response', response);

      if (!response || response.success === false) {
        const message = response?.error ? `${this.getLocalizedText('notification_recently_closed_empty')} (${response.error})` : this.getLocalizedText('notification_recently_closed_empty');
        this.showNotification(message, 'warning');
        return;
      }

      const items = Array.isArray(response) ? response : response.items;
      this.recentlyClosed = items || [];

      if (!items || items.length === 0) {
        console.log('[GHOST][RECENT] empty list');
        this.showNotification(this.getLocalizedText('notification_recently_closed_empty'), 'info');
        return;
      }

      this.showGScrollView(percent, 'recentlyClosed');
      this.renderRecentlyClosed(items, percent);
    } catch (error) {
      console.error('displayRecentlyClosedエラー:', error);
      this.showNotification(this.getLocalizedText('notification_recently_closed_empty'), 'warning');
    }
  }

  renderRecentlyClosed(items, percent = 0) {
    const gScrollView = document.querySelector('.g-scroll-view');
    if (!gScrollView) return;

    const header = gScrollView.querySelector('.g-scroll-header');
    if (header) {
      const titleElement = header.querySelector('.g-scroll-title');
      if (titleElement) {
        titleElement.textContent = `${this.getLocalizedText('recentlyClosed')} (${items.length})`;
      }
    }

    // 他のリストを非表示にする
    const historyList = document.getElementById('history-list');
    const bookmarkList = document.getElementById('bookmark-list');
    const favoritesList = document.getElementById('favorites-list');
    const keyListContainer = document.getElementById('keylist-list');
    const collectionContainer = document.getElementById('collection-detail');
    let recentlyClosedList = document.getElementById('recently-closed-list');

    if (historyList) historyList.style.display = 'none';
    if (bookmarkList) bookmarkList.style.display = 'none';
    if (favoritesList) favoritesList.style.display = 'none';
    if (keyListContainer) keyListContainer.style.display = 'none';
    if (collectionContainer) collectionContainer.style.display = 'none';
    if (recentlyClosedList) recentlyClosedList.style.display = 'none';

    recentlyClosedList = document.getElementById('recently-closed-list');
    if (!recentlyClosedList) {
      recentlyClosedList = document.createElement('div');
      recentlyClosedList.id = 'recently-closed-list';
      gScrollView.querySelector('.g-scroll-content').appendChild(recentlyClosedList);
    }

    recentlyClosedList.style.display = 'block';
    recentlyClosedList.innerHTML = '';

    items.forEach((item) => {
      const div = document.createElement('div');
      div.className = 'recently-closed-item';
      div.setAttribute('data-url', item.url || '');

      const faviconUrl = this.getFaviconUrl(item.url);
      const closedAt = item.closedAt ? this.formatDateTime(item.closedAt) : '';

      div.innerHTML = `
        <div class="recently-closed-content">
          <img src="${faviconUrl}" class="recently-closed-favicon" alt="favicon" onerror="this.style.display='none'">
          <div class="recently-closed-text">
            <div class="recently-closed-title">${item.title}</div>
            <div class="recently-closed-time">${closedAt}</div>
          </div>
        </div>
      `;

      div.addEventListener('click', () => window.open(item.url, '_blank'));
      recentlyClosedList.appendChild(div);
    });

    // フィルタを適用
    const filters = this.filterWords.recentlyClosed || { title: '', url: '' };
    this.applyFilter(filters.title, filters.url);

    this.adjustScrollPosition(percent, items.length);
  }

  // ファビコンのURLを生成するメソッド
  getFaviconUrl(url) {
    try {
      const urlObj = new URL(url);
      // Google Favicon Serviceを使用
      return `https://www.google.com/s2/favicons?domain=${urlObj.hostname}&sz=16`;
    } catch (e) {
      // URLが無効な場合はデフォルトアイコンを返す
      return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSIjNjY2NjY2Ii8+CjxwYXRoIGQ9Ik04IDRMMTIgOEw4IDEyVjRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K';
    }
  }

  // N％位置に応じてスクロール位置を調整するメソッド
  adjustScrollPosition(percent, totalItems) {
    const gScrollContent = document.querySelector('.g-scroll-content');
    if (!gScrollContent) {
      console.log('g-scroll-content要素が見つかりません');
      return;
    }
    
    // スクロールビューの高さを取得
    const scrollViewHeight = gScrollContent.clientHeight;
    
    // 実際の要素から高さを取得
    const items = gScrollContent.querySelectorAll('.bookmark-item, .history-item, .favorite-item, .collection-item, .recently-closed-item');
    let totalHeight = 0;
    
    if (items.length > 0) {
      // 実際の要素の高さを合計
      items.forEach(item => {
        totalHeight += item.offsetHeight;
      });
    } else {
      // 要素が存在しない場合は0
      totalHeight = 0;
    }
    
    // スクロール可能な最大距離を計算
    const maxScrollY = Math.max(0, totalHeight - scrollViewHeight);
    
    // パーセンテージを調整して、端の位置でも適切に表示されるようにする
    let adjustedPercent = percent;
    
    // 端の位置での調整（閾値を小さくして、より細かくスクロールできるようにする）
    if (percent <= 0.5) {
      // 0.5%以下の場合は0%として扱い、リストの上端を表示
      adjustedPercent = 0;
    } else if (percent >= 99.5) {
      // 99.5%以上の場合は100%として扱い、リストの下端を表示
      adjustedPercent = 100;
    } else {
      // 0.5%〜99.5%の範囲では、そのまま使用（より細かくスクロールできるようにする）
      adjustedPercent = Math.max(0, Math.min(100, percent));
    }
    
    // スクロール位置を計算（より正確な計算）
    let scrollY;
    if (maxScrollY <= 0) {
      // スクロール可能範囲がない場合は0
      scrollY = 0;
    } else {
      // スクロール可能範囲がある場合、パーセンテージに基づいて計算
      scrollY = (adjustedPercent / 100) * maxScrollY;
      // 整数値に丸める
      scrollY = Math.round(scrollY);
    }
    
    const beforeScrollTop = gScrollContent.scrollTop;
    console.log('スクロール位置調整:', {
      percent: percent.toFixed(2) + '%',
      adjustedPercent: adjustedPercent.toFixed(2) + '%',
      totalItems,
      scrollViewHeight,
      totalHeight,
      maxScrollY: maxScrollY.toFixed(0),
      scrollY: scrollY.toFixed(0),
      actualItemsCount: items.length,
      beforeScrollTop: beforeScrollTop.toFixed(0),
      scrollHeight: gScrollContent.scrollHeight.toFixed(0),
      clientHeight: gScrollContent.clientHeight.toFixed(0),
      canScroll: maxScrollY > 0
    });
    
    // スクロール位置を設定
    gScrollContent.scrollTop = scrollY;
    
    // スクロール位置が実際に設定されたか確認
    const actualScrollTop = gScrollContent.scrollTop;
    if (Math.abs(actualScrollTop - scrollY) > 1) {
      console.warn('⚠️ スクロール位置が正しく設定されませんでした:', {
        expected: scrollY,
        actual: actualScrollTop,
        diff: Math.abs(actualScrollTop - scrollY)
      });
      // 強制的に再設定を試みる
      requestAnimationFrame(() => {
        gScrollContent.scrollTop = scrollY;
        console.log('🔄 スクロール位置を再設定:', {
          before: gScrollContent.scrollTop,
          after: scrollY,
          actual: gScrollContent.scrollTop
        });
      });
    } else {
      console.log('✅ スクロール位置が正しく設定されました:', {
        before: beforeScrollTop,
        after: actualScrollTop,
        expected: scrollY
      });
    }
    
    // スクロール位置を追跡
    this.lastScrollPercent = percent;
    this.lastScrollType = this.getCurrentDisplayType();
  }

  // 現在のタイプに応じてスクロール位置を更新するメソッド
  updateScrollPositionForCurrentType(type) {
    console.log('updateScrollPositionForCurrentType呼び出し:', type);
    
    const gScrollContent = document.querySelector('.g-scroll-content');
    if (!gScrollContent) {
      console.log('g-scroll-content要素が見つかりません');
      return;
    }
    
    // 現在表示されているアイテム数を取得
    let items = [];
    let totalItems = 0;
    
    if (type === 'bookmarks') {
      items = gScrollContent.querySelectorAll('.bookmark-item');
      totalItems = items.length;
    } else if (type === 'history') {
      items = gScrollContent.querySelectorAll('.history-item');
      totalItems = items.length;
    } else if (type === 'favorites') {
      items = gScrollContent.querySelectorAll('.favorite-item');
      totalItems = items.length;
    } else if (type === 'collection') {
      items = gScrollContent.querySelectorAll('.collection-item');
      totalItems = items.length;
    } else if (type === 'recentlyClosed') {
      items = gScrollContent.querySelectorAll('.recently-closed-item');
      totalItems = items.length;
    }
    
    console.log('現在のアイテム数:', totalItems, 'type:', type);
    
    // 新しい位置でスクロール位置を調整
    this.adjustScrollPosition(this.currentPercent, totalItems);
  }

  async showGScrollView(percent = 0, type = 'bookmarks') {
    console.log('showGScrollView呼び出し, percent:', percent, 'type:', type);
    
    if (!this.gScrollView) {
      console.log('gScrollViewが存在しません');
      return;
    }
    
    // ダークモード状態と色情報をログ出力
    const isDark = await new Promise((resolve) => {
      chrome.storage.sync.get(['darkMode'], (result) => {
        resolve(result.darkMode === true || document.documentElement.getAttribute('data-theme') === 'dark');
      });
    });
    
    const rootStyle = getComputedStyle(document.documentElement);
    const scrollViewStyle = this.gScrollView ? getComputedStyle(this.gScrollView) : null;
    const headerElement = this.gScrollView?.querySelector('.g-scroll-header');
    const headerStyle = headerElement ? getComputedStyle(headerElement) : null;
    const firstItem = this.gScrollView?.querySelector('.bookmark-item, .history-item, .recently-closed-item, .favorite-item');
    const firstItemStyle = firstItem ? getComputedStyle(firstItem) : null;
    const firstTitle = firstItem?.querySelector('.bookmark-title, .history-title, .recently-closed-title, .favorite-title');
    const firstTitleStyle = firstTitle ? getComputedStyle(firstTitle) : null;
    
    console.log('🎨 [COLOR] showGScrollView - 色情報:', {
      isDark: isDark,
      dataTheme: document.documentElement.getAttribute('data-theme'),
      cssVariables: {
        '--ghost-scroll-foreground': rootStyle.getPropertyValue('--ghost-scroll-foreground').trim() || '未設定',
        '--ghost-scroll-bg': rootStyle.getPropertyValue('--ghost-scroll-bg').trim() || '未設定',
        '--ghost-scroll-header-bg': rootStyle.getPropertyValue('--ghost-scroll-header-bg').trim() || '未設定',
        '--ghost-scroll-item-text': rootStyle.getPropertyValue('--ghost-scroll-item-text').trim() || '未設定',
      },
      actualColors: {
        scrollView: {
          background: scrollViewStyle?.backgroundColor || 'N/A',
          color: scrollViewStyle?.color || 'N/A',
        },
        header: {
          background: headerStyle?.backgroundColor || 'N/A',
          color: headerStyle?.color || 'N/A',
        },
        firstItem: {
          background: firstItemStyle?.backgroundColor || 'N/A',
          color: firstItemStyle?.color || 'N/A',
        },
        firstTitle: {
          color: firstTitleStyle?.color || 'N/A',
          fontWeight: firstTitleStyle?.fontWeight || 'N/A',
        },
      }
    });
    
    // 表示状態を更新
    this.isVisible = true;
    
    // 現在の表示タイプを更新
    this.currentDisplayType = type;
    
    // ヘッダータイトルを更新
    const header = this.gScrollView.querySelector('.g-scroll-header');
    if (header) {
      const titleElement = header.querySelector('.g-scroll-title');
      if (titleElement) {
        if (type === 'keylist') {
          titleElement.textContent = this.getLocalizedText('keylist');
        } else if (type === 'collection') {
          titleElement.textContent = this.getLocalizedText('collection');
        } else {
        titleElement.textContent = this.getLocalizedText(type);
        }
      }
      
      // フィルタ入力欄を更新（履歴、ブックマーク、最近閉じたタブのみ表示）
      const filterContainer = header.querySelector('.g-scroll-filter-container');
      const filterTitleInput = header.querySelector('#g-scroll-filter-title');
      const filterUrlInput = header.querySelector('#g-scroll-filter-url');
      const filterTitleClear = header.querySelector('#g-scroll-filter-title-clear');
      const filterUrlClear = header.querySelector('#g-scroll-filter-url-clear');
      
      if (filterContainer) {
        if (type === 'history' || type === 'bookmarks' || type === 'recentlyClosed') {
          filterContainer.style.display = 'block';
          // 保存されたフィルタワードを設定
          const savedFilters = this.filterWords[type] || { title: '', url: '' };
          if (filterTitleInput) {
            filterTitleInput.value = savedFilters.title || '';
            if (filterTitleClear) {
              filterTitleClear.style.display = savedFilters.title ? 'block' : 'none';
            }
          }
          if (filterUrlInput) {
            filterUrlInput.value = savedFilters.url || '';
            if (filterUrlClear) {
              filterUrlClear.style.display = savedFilters.url ? 'block' : 'none';
            }
          }
        } else {
          filterContainer.style.display = 'none';
        }
      }
    }
    
    // コンテンツを非表示にする
    const historyList = document.getElementById('history-list');
    const bookmarkList = document.getElementById('bookmark-list');
    const favoritesList = document.getElementById('favorites-list');
    const keyListContainer = document.getElementById('keylist-list');
    const collectionContainer = document.getElementById('collection-detail');
    const recentlyClosedList = document.getElementById('recently-closed-list');
    const historyLimitDropdown = document.getElementById('history-limit-dropdown');
    
    if (historyList) historyList.style.display = 'none';
    if (bookmarkList) bookmarkList.style.display = 'none';
    if (favoritesList) favoritesList.style.display = 'none';
    if (keyListContainer) keyListContainer.style.display = 'none';
    if (collectionContainer) collectionContainer.style.display = 'none';
    if (recentlyClosedList) recentlyClosedList.style.display = 'none';
    
    // 履歴数選択ドロップダウンの表示制御
    if (historyLimitDropdown) {

    }
    
    // タイプに応じてコンテンツを表示
    if (type === 'history') {
      if (historyList) historyList.style.display = 'block';
    } else if (type === 'bookmarks') {
      if (bookmarkList) bookmarkList.style.display = 'block';
    } else if (type === 'favorites') {
      if (favoritesList) favoritesList.style.display = 'block';
    } else if (type === 'keylist') {
      if (keyListContainer) keyListContainer.style.display = 'block';
    } else if (type === 'collection') {
      if (collectionContainer) collectionContainer.style.display = 'block';
    } else if (type === 'recentlyClosed') {
      if (recentlyClosedList) recentlyClosedList.style.display = 'block';
    }
    
    // Gスクロールビューを即座に表示
    this.gScrollView.style.display = 'block';
    this.gScrollView.style.opacity = '1';
    
    // 即座にスクロール位置を調整
    const items = this.gScrollView.querySelectorAll('.bookmark-item, .history-item, .favorite-item, .collection-item, .recently-closed-item');
    this.adjustScrollPosition(percent, items.length);
    
    // 外側クリックで閉じる機能を追加
    this.addOutsideClickHandler();
    
    // スクロールビューが表示された時に、ポップアップの位置を更新
    // ゴーストエリア内にいる場合のみ更新
    if (this.isInGhostArea && this.ghostInterface && this.positionPopup) {
      const rect = this.ghostInterface.getBoundingClientRect();
      // 現在のマウス位置を使用（保存されている値）
      const mouseX = this.currentMouseX || (rect.left + rect.width / 2);
      this.updatePositionPopup(mouseX, rect);
    }
    
    console.log('Gスクロールビュー表示完了, type:', type);
  }

  // Gスクロールビュー外クリックで閉じる機能
  addOutsideClickHandler() {
    // 既存のイベントリスナーを削除
    if (this.outsideClickHandler) {
      document.removeEventListener('click', this.outsideClickHandler);
    }
    
    this.outsideClickHandler = (e) => {
      if (this.gScrollView && !this.gScrollView.contains(e.target)) {
        console.log('Gスクロールビュー外クリック検出');
        this.hideGScrollView();
      }
    };
    
    // 少し遅延させてからイベントリスナーを追加（現在のクリックイベントを無視するため）
    setTimeout(() => {
      document.addEventListener('click', this.outsideClickHandler);
    }, 100);
  }

  hideGScrollView() {
    console.log('=== hideGScrollViewデバッグ開始 ===');
    console.log('gScrollViewの存在:', !!this.gScrollView);
    
    if (this.gScrollView) {
      console.log('hideGScrollView呼び出し');
      console.log('非表示前の状態 - display:', this.gScrollView.style.display, 'opacity:', this.gScrollView.style.opacity);
      
      // 即座に非表示
      this.gScrollView.style.display = 'none';
      this.gScrollView.style.opacity = '0';
      this.isVisible = false;
      
      console.log('非表示後の状態 - display:', this.gScrollView.style.display, 'opacity:', this.gScrollView.style.opacity);
      
      // すべてのリストを非表示にしてcurrentTypeをリセット
      const historyList = document.getElementById('history-list');
      const bookmarkList = document.getElementById('bookmark-list');
      const favoritesList = document.getElementById('favorites-list');
      const keyListContainer = document.getElementById('keylist-list');
      const collectionContainer = document.getElementById('collection-detail');
      const recentlyClosedList = document.getElementById('recently-closed-list');
      
      console.log('各リストの存在確認:');
      console.log('- historyList:', !!historyList);
      console.log('- bookmarkList:', !!bookmarkList);
      console.log('- favoritesList:', !!favoritesList);
      console.log('- keyListContainer:', !!keyListContainer);
      console.log('- recentlyClosedList:', !!recentlyClosedList);
      
      if (historyList) {
        console.log('- historyList非表示前:', historyList.style.display);
        historyList.style.display = 'none';
        console.log('- historyList非表示後:', historyList.style.display);
      }
      if (bookmarkList) {
        console.log('- bookmarkList非表示前:', bookmarkList.style.display);
        bookmarkList.style.display = 'none';
        console.log('- bookmarkList非表示後:', bookmarkList.style.display);
      }
      if (favoritesList) {
        console.log('- favoritesList非表示前:', favoritesList.style.display);
        favoritesList.style.display = 'none';
        console.log('- favoritesList非表示後:', favoritesList.style.display);
      }
      if (keyListContainer) {
        console.log('- keyListContainer非表示前:', keyListContainer.style.display);
        keyListContainer.style.display = 'none';
        console.log('- keyListContainer非表示後:', keyListContainer.style.display);
      }
      if (collectionContainer) {
        console.log('- collectionContainer非表示前:', collectionContainer.style.display);
        collectionContainer.style.display = 'none';
        console.log('- collectionContainer非表示後:', collectionContainer.style.display);
      }
      if (recentlyClosedList) {
        console.log('- recentlyClosedList非表示前:', recentlyClosedList.style.display);
        recentlyClosedList.style.display = 'none';
        console.log('- recentlyClosedList非表示後:', recentlyClosedList.style.display);
      }
      
      // フィルタ欄をリセット
      const filterTitleInput = this.gScrollView?.querySelector('#g-scroll-filter-title');
      const filterUrlInput = this.gScrollView?.querySelector('#g-scroll-filter-url');
      const filterTitleClear = this.gScrollView?.querySelector('#g-scroll-filter-title-clear');
      const filterUrlClear = this.gScrollView?.querySelector('#g-scroll-filter-url-clear');
      
      // 現在の表示タイプを取得して、そのタイプのフィルタワードをクリア
      const currentType = this.currentDisplayType;
      if (currentType && (currentType === 'history' || currentType === 'bookmarks' || currentType === 'recentlyClosed')) {
        // 保存されたフィルタワードをクリア
        this.filterWords[currentType] = { title: '', url: '' };
        // ストレージからも削除
        const keyMap = {
          'history': { title: 'filterHistoryTitle', url: 'filterHistoryUrl' },
          'bookmarks': { title: 'filterBookmarksTitle', url: 'filterBookmarksUrl' },
          'recentlyClosed': { title: 'filterRecentlyClosedTitle', url: 'filterRecentlyClosedUrl' }
        };
        const keys = keyMap[currentType];
        if (keys) {
          chrome.storage.sync.set({
            [keys.title]: '',
            [keys.url]: ''
          }, () => {
            console.log(`[FILTER] ${currentType}のフィルタワードをストレージからクリアしました`);
          });
        }
      }
      
      // フィルタ入力欄の値をクリア
      if (filterTitleInput) {
        filterTitleInput.value = '';
      }
      if (filterUrlInput) {
        filterUrlInput.value = '';
      }
      if (filterTitleClear) {
        filterTitleClear.style.display = 'none';
      }
      if (filterUrlClear) {
        filterUrlClear.style.display = 'none';
      }
      
      console.log('[FILTER] フィルタ欄をリセットしました', { currentType, filterWords: this.filterWords });
      
      // 外側クリックハンドラーを削除
      if (this.outsideClickHandler) {
        console.log('外側クリックハンドラーを削除');
        document.removeEventListener('click', this.outsideClickHandler);
        this.outsideClickHandler = null;
      }
      
      console.log('✅ Gスクロールビュー非表示完了、currentTypeをリセット、フィルタ欄をリセット');
    } else {
      console.log('❌ gScrollViewが存在しません');
    }
    console.log('=== hideGScrollViewデバッグ終了 ===');
  }

  // ブラウザの言語設定に合わせてテキストを翻訳するメソッド
  getLocalizedText(key, substitutions = []) {
    let chromeMessage = null;
    if (typeof chrome !== 'undefined' && chrome.i18n && typeof chrome.i18n.getMessage === 'function') {
      try {
        const substitutionArg =
          substitutions.length === 0
            ? undefined
            : substitutions.length === 1
              ? substitutions[0]
              : substitutions;
        chromeMessage = chrome.i18n.getMessage(key, substitutionArg);
      } catch (error) {
        console.warn('[Ghost][i18n] getMessage failed:', key, error);
      }
    }

    if (chromeMessage) {
      return chromeMessage;
    }

    const language =
      (typeof chrome !== 'undefined' && chrome.i18n && chrome.i18n.getUILanguage
        ? chrome.i18n.getUILanguage()
        : navigator.language || 'en')
        .toLowerCase();

    const normalizedLang = language.includes('zh') ? 'zh-CN' : language.split('-')[0];
    const candidates = Array.from(new Set([language, normalizedLang, 'en']));

    const entry = GHOST_I18N_STRINGS[key];
    if (!entry) {
      console.warn('[Ghost][i18n] Missing translation key:', key);
      return key;
    }

    let message = null;
    for (const candidate of candidates) {
      if (entry[candidate]) {
        message = entry[candidate];
        break;
      }
    }

    if (!message) {
      message = entry.en || key;
    }

    return substitutions.reduce((result, value, index) => {
      const pattern = new RegExp(`\\$${index + 1}`, 'g');
      return result.replace(pattern, value);
    }, message);
  }

  // お気に入りを切り替えるメソッド
  toggleFavorite(item) {
    const existingIndex = this.favorites.findIndex(fav => fav.url === item.url);
    
    if (existingIndex >= 0) {
      // お気に入りから削除
      this.favorites.splice(existingIndex, 1);
      console.log('お気に入りから削除:', item.title);
    } else {
      // お気に入りに追加
      const favoriteItem = {
        url: item.url,
        title: item.title,
        addedAt: Date.now(),
        icon: this.getFaviconUrl(item.url)
      };
      this.favorites.push(favoriteItem);
      console.log('お気に入りに追加:', item.title);
    }
    
    // お気に入りリストを保存
    this.saveFavorites();
  }



  // お気に入りリストを保存するメソッド
  saveFavorites() {
    chrome.storage.sync.set({ favorites: this.favorites }, () => {
      console.log('お気に入りリストを保存しました:', this.favorites.length, '件');
    });
  }

  // キー別リストを読み込むメソッド
  async loadKeyLists() {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['keyLists'], (result) => {
        this.keyLists = result.keyLists || {};
        console.log('キー別リストを読み込みました:', Object.keys(this.keyLists).length, '個のキー');
        resolve();
      });
    });
  }

  // キー別リストを保存するメソッド
  saveKeyLists() {
    chrome.storage.sync.set({ keyLists: this.keyLists }, () => {
      console.log('キー別リストを保存しました:', Object.keys(this.keyLists).length, '個のキー');
    });
  }

  // コレクションを読み込むメソッド
  async loadCollections() {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['collections'], (result) => {
        this.collections = result.collections || {};
        console.log('タブコレクションを読み込みました:', Object.keys(this.collections).length, '個のキー');
        resolve();
      });
    });
  }

  // コレクションを保存するメソッド
  saveCollections() {
    chrome.storage.sync.set({ collections: this.collections }, () => {
      console.log('タブコレクションを保存しました:', Object.keys(this.collections).length, '個のキー');
    });
  }

  // ストレージ変更を監視
  observeStorageChanges() {
    chrome.storage.onChanged.addListener((changes, areaName) => {
      if (areaName !== 'sync') return;

      if (changes.darkMode) {
        const isDark = changes.darkMode.newValue === true;
        this.applyTheme(isDark);
        console.log('ストレージ変更: darkMode を更新:', isDark);
      }

      if (changes.autoOpenOnHover) {
        this.autoOpenOnHover = changes.autoOpenOnHover.newValue === true;
        console.log('ストレージ変更: autoOpenOnHover を更新:', this.autoOpenOnHover);
        // モードが無効になった場合は固定タイプをリセット
        if (!this.autoOpenOnHover) {
          this.fixedDisplayType = null;
        }
      }

      if (changes.keyLists) {
        this.keyLists = changes.keyLists.newValue || {};
        console.log('ストレージ変更: keyLists を更新');
      }

      if (changes.collections) {
        this.collections = changes.collections.newValue || {};
        console.log('ストレージ変更: collections を更新');
      }
    });
  }

  // 指定されたキーのリストを取得するメソッド
  getKeyList(key) {
    if (!this.keyLists[key]) {
      this.keyLists[key] = [];
    }
    return this.keyLists[key];
  }

  // タブコレクションを取得するメソッド
  getCollection(key) {
    if (!this.collections[key]) {
      this.collections[key] = {
        id: key,
        name: `Collection ${key.toUpperCase()}`,
        note: '',
        savedAt: Date.now(),
        tabs: []
      };
    }
    return this.collections[key];
  }

  // キータイプの判定メソッド
  isDigitKey(key) {
    return /^[1-9]$/.test(key);
  }

  isLetterKey(key) {
    return /^[a-zA-Z]$/.test(key);
  }

  normalizeLetterKey(key) {
    return key.toLowerCase();
  }

  // 現在のウィンドウタブ情報を取得
  fetchCurrentWindowTabs() {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage({ action: 'getCurrentWindowTabs' }, (response) => {
        if (chrome.runtime.lastError) {
          console.error('タブ情報取得エラー:', chrome.runtime.lastError);
          reject(chrome.runtime.lastError);
          return;
        }
        if (!response || !response.success) {
          const error = new Error(response?.error || 'タブ情報の取得に失敗しました');
          console.error(error);
          reject(error);
          return;
        }
        resolve(response.tabs || []);
      });
    });
  }

  // 現在のウィンドウをコレクションとして保存
  async saveCurrentWindowAsCollection(key) {
    try {
      const tabs = await this.fetchCurrentWindowTabs();
      if (!tabs || tabs.length === 0) {
        this.showNotification(this.getLocalizedText('notification_no_tabs_available'), 'warning');
        return;
      }

      const filteredTabs = tabs.filter(tab => tab.url && !tab.url.startsWith('chrome://'));
      console.log('コレクション保存リクエスト:', {
        key,
        totalTabs: tabs.length,
        savableTabs: filteredTabs.length
      });
      if (filteredTabs.length === 0) {
        this.showNotification(this.getLocalizedText('notification_no_savable_tabs'), 'warning');
        return;
      }

      const existing = this.collections[key];
      if (existing && existing.tabs && existing.tabs.length > 0) {
        const overwrite = await this.showConfirmDialog(this.getLocalizedText('confirm_overwrite_collection', [key]));
        if (!overwrite) {
          this.showNotification(this.getLocalizedText('notification_overwrite_cancelled'), 'info', { duration: 2000 });
          return;
        }
        console.log('既存コレクションを上書きします:', {
          key,
          previousTabCount: existing.tabs.length
        });
      }

      const now = Date.now();
      const normalizedTabs = filteredTabs.map((tab, index) => ({
        url: tab.url,
        title: tab.title || tab.url,
        favIconUrl: tab.favIconUrl || this.getFaviconUrl(tab.url),
        pinned: !!tab.pinned,
        muted: !!tab.mutedInfo?.muted,
        index: index,
        savedAt: now
      }));

      if (normalizedTabs.length === 0) {
        this.showNotification(this.getLocalizedText('notification_no_savable_tabs'), 'warning');
        return;
      }

      this.collections[key] = {
        id: key,
        name: existing?.name || `Collection ${key.toUpperCase()}`,
        note: existing?.note || '',
        savedAt: existing?.savedAt || now,
        updatedAt: now,
        tabs: normalizedTabs
      };

      this.saveCollections();
      this.showNotification(this.getLocalizedText('notification_collection_saved', [this.collections[key].name]), 'success');
      console.log('コレクション保存完了:', {
        key,
        tabCount: normalizedTabs.length,
        name: this.collections[key].name
      });

      // a-zキーの場合、タブを閉じて管理画面をピン留めで開く
      if (this.isLetterKey(key)) {
        try {
          console.log('[GHOST][SAVE] a-zキー保存後処理開始');
          
          // まず管理画面が既に開かれているかチェック
          const checkResponse = await new Promise((resolve) => {
            chrome.runtime.sendMessage({
              action: 'checkManagerTabExists'
            }, (response) => {
              if (chrome.runtime.lastError) {
                console.error('[GHOST][SAVE] 管理画面チェックエラー:', chrome.runtime.lastError);
                resolve({ exists: false });
              } else {
                resolve(response || { exists: false });
              }
            });
          });

          console.log('[GHOST][SAVE] 管理画面の存在:', checkResponse.exists);

          const currentWindowTabs = await this.fetchCurrentWindowTabs();
          const managerUrl = chrome.runtime.getURL('manager/manager.html');
          
          // 管理画面以外のタブを取得し、インデックス順にソート（右から閉じるため、インデックスが大きい順）
          const tabsToClose = currentWindowTabs
            .filter(tab => tab.url && !tab.url.startsWith('chrome://') && tab.url !== managerUrl)
            .sort((a, b) => (b.index || 0) - (a.index || 0)); // インデックスが大きい順（右から）
          
          const tabIdsToClose = tabsToClose.map(tab => tab.id);

          console.log('[GHOST][SAVE] 現在のタブ数:', currentWindowTabs.length, '閉じるタブ数:', tabIdsToClose.length);

          // 管理画面が存在しない場合のみ開く
          if (!checkResponse.exists) {
            // background script経由で管理画面を開いてタブを閉じる
            chrome.runtime.sendMessage({
              action: 'openManagerAndCloseTabs',
              tabIdsToClose: tabIdsToClose
            }, (response) => {
              if (chrome.runtime.lastError) {
                console.error('[GHOST][SAVE] 管理画面開封エラー:', chrome.runtime.lastError);
              } else if (response && response.success) {
                console.log('[GHOST][SAVE] タブを閉じて管理画面を開きました');
              } else {
                console.error('[GHOST][SAVE] 管理画面開封失敗:', response?.error);
              }
            });
          } else {
            // 管理画面が既にある場合は、タブを閉じるだけ
            if (tabIdsToClose.length > 0) {
              chrome.runtime.sendMessage({
                action: 'closeTabs',
                tabIds: tabIdsToClose
              }, (response) => {
                if (chrome.runtime.lastError) {
                  console.error('[GHOST][SAVE] タブクローズエラー:', chrome.runtime.lastError);
                } else if (response && response.success) {
                  console.log('[GHOST][SAVE] タブを閉じました（管理画面は既に存在）');
                }
              });
            }
          }
        } catch (error) {
          console.error('[GHOST][SAVE] タブクローズ/管理画面開封エラー:', error);
        }
      }
    } catch (error) {
      console.error('コレクション保存エラー:', error);
      this.showNotification(this.getLocalizedText('notification_collection_save_failed'), 'error');
    }
  }

  // コレクションを表示
  displayCollection(key) {
    const normalizedKey = this.normalizeLetterKey(key);
    const collection = this.collections[normalizedKey];

    if (!collection || !collection.tabs || collection.tabs.length === 0) {
      this.showNotification(this.getLocalizedText('notification_collection_empty', [normalizedKey]), 'warning');
      return;
    }

    this.showGScrollView(this.currentPercent, 'collection');
    this.renderCollection(normalizedKey, collection);
  }

  // コレクション表示をレンダリング
  renderCollection(key, collection) {
    const gScrollView = document.querySelector('.g-scroll-view');
    if (!gScrollView) return;

    const header = gScrollView.querySelector('.g-scroll-header');
    if (header) {
      const titleNode = header.querySelector('.g-scroll-title');
      if (titleNode) {
        titleNode.textContent = this.getLocalizedText('collection_header_title', [
          collection.name,
          collection.tabs.length
        ]);
      } else if (header.firstChild && header.firstChild.nodeType === Node.TEXT_NODE) {
        header.firstChild.textContent = this.getLocalizedText('collection_header_title', [
          collection.name,
          collection.tabs.length
        ]);
      }
    }

    const contentRoot = gScrollView.querySelector('.g-scroll-content');
    if (!contentRoot) return;

    const historyList = document.getElementById('history-list');
    const bookmarkList = document.getElementById('bookmark-list');
    const favoritesList = document.getElementById('favorites-list');
    const keyListContainer = document.getElementById('keylist-list');

    if (historyList) historyList.style.display = 'none';
    if (bookmarkList) bookmarkList.style.display = 'none';
    if (favoritesList) favoritesList.style.display = 'none';
    if (keyListContainer) keyListContainer.style.display = 'none';

    let collectionContainer = document.getElementById('collection-detail');
    if (!collectionContainer) {
      collectionContainer = document.createElement('div');
      collectionContainer.id = 'collection-detail';
      collectionContainer.className = 'collection-detail';
      contentRoot.appendChild(collectionContainer);
    }

    collectionContainer.style.display = 'block';
    collectionContainer.innerHTML = '';

    const metadata = document.createElement('div');
    metadata.className = 'collection-metadata';
    metadata.innerHTML = `
      <div class="collection-meta-header">
        <div class="collection-meta-info">
          <div class="collection-meta-name">${collection.name}</div>
          <div class="collection-meta-sub">
            <span>${this.getLocalizedText('collection_tab_count_label', [collection.tabs.length])}</span>
            <span>${this.getLocalizedText('collection_saved_label', [this.formatDateTime(collection.savedAt)])}</span>
            <span>${this.getLocalizedText('collection_updated_label', [this.formatDateTime(collection.updatedAt || collection.savedAt)])}</span>
          </div>
        </div>
        <div class="collection-meta-actions">
          <button class="collection-edit-button">${this.getLocalizedText('collection_edit_button')}</button>
          <button class="collection-export-button">${this.getLocalizedText('collection_export_button')}</button>
        </div>
      </div>
      <div class="collection-meta-note">${collection.note ? this.escapeHtml(collection.note) : this.getLocalizedText('collection_note_empty')}</div>
    `;
    collectionContainer.appendChild(metadata);

    const listWrapper = document.createElement('div');
    listWrapper.className = 'collection-tabs';
    collectionContainer.appendChild(listWrapper);

    collection.tabs.forEach((tab, index) => {
      const item = document.createElement('div');
      item.className = 'collection-item';
      item.innerHTML = `
        <div class="collection-content">
          <img src="${tab.favIconUrl}" alt="" class="collection-favicon" onerror="this.style.display='none'">
          <div class="collection-text">
            <div class="collection-title">${this.escapeHtml(tab.title)}</div>
            <div class="collection-url">${this.escapeHtml(tab.url)}</div>
          </div>
          <div class="collection-actions">
            <button class="collection-open-single" data-index="${index}">${this.getLocalizedText('collection_open_single_button')}</button>
            <button class="collection-remove" data-index="${index}">${this.getLocalizedText('collection_remove_button')}</button>
          </div>
        </div>
      `;
      listWrapper.appendChild(item);
    });

    const editButton = metadata.querySelector('.collection-edit-button');
    if (editButton) {
      editButton.addEventListener('click', () => {
        this.editCollectionMetadata(key);
      });
    }

    const exportButton = metadata.querySelector('.collection-export-button');
    if (exportButton) {
      exportButton.addEventListener('click', () => {
        this.exportCollectionAsJson(key);
      });
    }

    listWrapper.querySelectorAll('.collection-open-single').forEach((btn) => {
      btn.addEventListener('click', (e) => {
        const idx = Number(e.currentTarget.getAttribute('data-index'));
        const target = collection.tabs[idx];
        if (target) {
          window.open(target.url, '_blank');
        }
      });
    });

    listWrapper.querySelectorAll('.collection-remove').forEach((btn) => {
      btn.addEventListener('click', (e) => {
        const idx = Number(e.currentTarget.getAttribute('data-index'));
        this.removeTabFromCollection(key, idx);
      });
    });

    this.adjustScrollPosition(this.currentPercent, collection.tabs.length);
  }

  // コレクションのタブを削除
  async removeTabFromCollection(key, index) {
    const collection = this.collections[key];
    if (!collection) return;

    const target = collection.tabs[index];
    if (!target) return;

    const confirmed = await this.showConfirmDialog(
      this.getLocalizedText('confirm_remove_tab_from_collection', [target.title || target.url])
    );
    if (!confirmed) {
      return;
    }

    collection.tabs.splice(index, 1);
    collection.updatedAt = Date.now();

    if (collection.tabs.length === 0) {
      delete this.collections[key];
      this.showNotification(
        this.getLocalizedText('notification_collection_deleted_empty', [collection.name]),
        'info'
      );
    }

    this.saveCollections();
    if (collection.tabs.length > 0) {
      this.renderCollection(key, collection);
    } else {
      this.hideGScrollView();
    }
  }

  // コレクションのメタデータを編集
  editCollectionMetadata(key) {
    const collection = this.collections[key];
    if (!collection) return;

    const newName = window.prompt(
      this.getLocalizedText('prompt_collection_name'),
      collection.name || ''
    );
    if (newName === null) return;

    const newNote = window.prompt(
      this.getLocalizedText('prompt_collection_note'),
      collection.note || ''
    );
    if (newNote === null) return;

    collection.name = newName.trim() || collection.name;
    collection.note = newNote.trim();
    collection.updatedAt = Date.now();

    this.saveCollections();
    this.showNotification(this.getLocalizedText('notification_collection_updated'), 'success');
    this.renderCollection(key, collection);
  }

  // コレクションをJSONとしてエクスポート
  async exportCollectionAsJson(key) {
    const collection = this.collections[key];
    if (!collection) {
      this.showNotification(this.getLocalizedText('notification_export_target_missing'), 'warning');
      return;
    }

    const confirmed = await this.showConfirmDialog(
      this.getLocalizedText('confirm_export_collection', [collection.name])
    );
    if (!confirmed) return;

    const dataStr = JSON.stringify(collection, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const filename = `ghost-collection-${collection.id}-${Date.now()}.json`;

    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = filename;
    anchor.click();

    setTimeout(() => {
      URL.revokeObjectURL(url);
    }, 1000);

    this.showNotification(this.getLocalizedText('notification_json_downloaded'), 'success', { duration: 4000 });
  }

  // 日時表示整形
  formatDateTime(timestamp) {
    if (!timestamp) return '-';
    const date = new Date(timestamp);
    const locale =
      (typeof chrome !== 'undefined' && chrome.i18n && chrome.i18n.getUILanguage
        ? chrome.i18n.getUILanguage()
        : navigator.language || 'en');
    const formatter = new Intl.DateTimeFormat(locale, {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
    return formatter.format(date);
  }

  // HTMLエスケープ
  escapeHtml(value) {
    if (typeof value !== 'string') return value;
    return value
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  // ページリストを開く前に確認
  async confirmAndOpenPages(key) {
    const keyList = this.getKeyList(key);
    if (!keyList || keyList.length === 0) {
      this.showNotification(this.getLocalizedText('notification_no_saved_pages_for_key', [key]), 'warning');
      return;
    }

    const confirmed = await this.showConfirmDialog(
      this.getLocalizedText('confirm_open_key_items', [key, keyList.length])
    );
    if (!confirmed) {
      this.showNotification(this.getLocalizedText('notification_open_cancelled'), 'info', { duration: 2000 });
      return;
    }

    this.openAllPagesInKeyList(key);
  }

  async confirmAndRestoreCollection(key) {
    const collection = this.collections[key];
    if (!collection || !collection.tabs || collection.tabs.length === 0) {
      this.showNotification(this.getLocalizedText('notification_collection_not_found', [key]), 'warning');
      return;
    }

    if (typeof chrome === 'undefined' || !chrome.runtime || !chrome.runtime.sendMessage) {
      console.warn('chrome.runtime が利用できない環境です。フォールバックとして新しいタブで開きます。');
      collection.tabs.forEach(tab => {
        if (tab.url && !tab.url.startsWith('chrome://')) {
          window.open(tab.url, '_blank');
        }
      });
      return;
    }

    // 3択ダイアログを表示
    this.showRestoreOptionsDialog(collection, key);
  }

  async showConfirmDialog(message) {
    return new Promise((resolve) => {
      chrome.storage.sync.get(['darkMode'], async (result) => {
        const isDark = result.darkMode === true || document.documentElement.getAttribute('data-theme') === 'dark';
        
        console.log('🎨 [COLOR] showConfirmDialog - 色情報:', {
          isDark: isDark,
          dataTheme: document.documentElement.getAttribute('data-theme'),
          storageDarkMode: result.darkMode,
          message: message.substring(0, 50) + '...',
        });

        const dialog = document.createElement('div');
        dialog.className = 'ghost-confirm-dialog';
        if (isDark) {
          dialog.setAttribute('data-theme', 'dark');
        }
        dialog.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: ${isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.5)'};
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 1000000;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        `;

        const dialogContent = document.createElement('div');
        dialogContent.style.cssText = `
          background: ${isDark ? '#1a1a1a' : 'white'};
          padding: 24px;
          border-radius: 8px;
          max-width: 400px;
          width: 90%;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          border: ${isDark ? '1px solid #374151' : 'none'};
        `;

        const prompt = document.createElement('div');
        prompt.textContent = message;
        prompt.style.cssText = `
          margin-bottom: 20px;
          white-space: pre-line;
          line-height: 1.5;
          color: ${isDark ? '#cbd5e1' : '#333'};
          font-weight: 400;
          font-size: 14px;
        `;

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
          display: flex;
          gap: 8px;
          justify-content: flex-end;
        `;

        const createButton = (text, value) => {
          const button = document.createElement('button');
          button.textContent = text;
          button.style.cssText = `
            padding: 8px 16px;
            border: 1px solid ${isDark ? '#374151' : '#ccc'};
            border-radius: 4px;
            background: ${isDark ? '#0f172a' : 'white'};
            color: ${isDark ? '#cbd5e1' : '#333'};
            cursor: pointer;
            font-size: 14px;
            font-weight: 400;
            transition: background 0.2s;
            min-width: 80px;
          `;
          button.addEventListener('mouseenter', () => {
            button.style.background = isDark ? '#374151' : '#f5f5f5';
          });
          button.addEventListener('mouseleave', () => {
            button.style.background = isDark ? '#0f172a' : 'white';
          });
          button.addEventListener('click', () => {
            document.body.removeChild(dialog);
            resolve(value);
          });
          return button;
        };

        const okText = this.getLocalizedText('common_ok') || 'OK';
        const cancelText = this.getLocalizedText('common_cancel') || 'キャンセル';
        const cancelButton = createButton(cancelText, false);
        const okButton = createButton(okText, true);

        buttonContainer.appendChild(cancelButton);
        buttonContainer.appendChild(okButton);

        dialogContent.appendChild(prompt);
        dialogContent.appendChild(buttonContainer);
        dialog.appendChild(dialogContent);
        document.body.appendChild(dialog);
        
        // ダイアログ表示後の実際の色をログ出力
        requestAnimationFrame(() => {
          const dialogStyle = getComputedStyle(dialogContent);
          const promptStyle = getComputedStyle(prompt);
          const okButton = buttonContainer.querySelector('button:last-child');
          const cancelButton = buttonContainer.querySelector('button:first-child');
          const okButtonStyle = okButton ? getComputedStyle(okButton) : null;
          const cancelButtonStyle = cancelButton ? getComputedStyle(cancelButton) : null;
          
          console.log('🎨 [COLOR] showConfirmDialog - 実際の色情報:', {
            isDark: isDark,
            actualColors: {
              dialogContent: {
                background: dialogStyle.backgroundColor,
                color: dialogStyle.color,
              },
              prompt: {
                color: promptStyle.color,
                fontWeight: promptStyle.fontWeight,
              },
              okButton: {
                background: okButtonStyle?.backgroundColor || 'N/A',
                color: okButtonStyle?.color || 'N/A',
                borderColor: okButtonStyle?.borderColor || 'N/A',
              },
              cancelButton: {
                background: cancelButtonStyle?.backgroundColor || 'N/A',
                color: cancelButtonStyle?.color || 'N/A',
                borderColor: cancelButtonStyle?.borderColor || 'N/A',
              },
            }
          });
        });

        // 背景クリックで閉じる（キャンセル）
        dialog.addEventListener('click', (e) => {
          if (e.target === dialog) {
            document.body.removeChild(dialog);
            resolve(false);
          }
        });
      });
    });
  }

  async showRestoreOptionsDialog(collection, key) {
    const promptText = this.getLocalizedText('restore_collection_prompt', [collection.name, collection.tabs.length]);
    const option1 = this.getLocalizedText('restore_option_existing_window');
    const option2 = this.getLocalizedText('restore_option_new_window');
    const option3 = this.getLocalizedText('restore_option_cancel');

    // ダークモード設定を取得（document.documentElementのdata-theme属性も確認）
    const isDark = await new Promise((resolve) => {
      chrome.storage.sync.get(['darkMode'], (result) => {
        const storageDark = result.darkMode === true;
        const htmlDark = document.documentElement.getAttribute('data-theme') === 'dark';
        resolve(storageDark || htmlDark);
      });
    });
    
    console.log('🎨 [COLOR] showRestoreOptionsDialog - 色情報:', {
      isDark: isDark,
      dataTheme: document.documentElement.getAttribute('data-theme'),
      storageDarkMode: await new Promise((resolve) => {
        chrome.storage.sync.get(['darkMode'], (result) => resolve(result.darkMode));
      }),
      collectionName: collection.name,
      tabCount: collection.tabs.length,
      dialogColors: {
        background: isDark ? '#1a1a1a' : 'white',
        text: isDark ? '#cbd5e1' : '#333',
        buttonBg: isDark ? '#0f172a' : 'white',
        buttonText: isDark ? '#cbd5e1' : '#333',
      }
    });

    // カスタムダイアログを作成
    const dialog = document.createElement('div');
    dialog.className = 'ghost-confirm-dialog';
    if (isDark) {
      dialog.setAttribute('data-theme', 'dark');
    }
    dialog.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: ${isDark ? 'rgba(0, 0, 0, 0.7)' : 'rgba(0, 0, 0, 0.5)'};
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

    const dialogContent = document.createElement('div');
    dialogContent.style.cssText = `
      background: ${isDark ? '#1a1a1a' : 'white'};
      padding: 24px;
      border-radius: 8px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      border: ${isDark ? '1px solid #374151' : 'none'};
    `;

    const prompt = document.createElement('div');
    prompt.textContent = promptText;
    prompt.style.cssText = `
      margin-bottom: 20px;
      white-space: pre-line;
      line-height: 1.5;
      color: ${isDark ? '#cbd5e1' : '#333'};
      font-weight: 400;
      font-size: 14px;
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: 8px;
    `;

    const createButton = (text, action) => {
      const button = document.createElement('button');
      button.textContent = text;
      button.style.cssText = `
        padding: 10px 16px;
        border: 1px solid ${isDark ? '#374151' : '#ccc'};
        border-radius: 4px;
        background: ${isDark ? '#0f172a' : 'white'};
        color: ${isDark ? '#cbd5e1' : '#333'};
        cursor: pointer;
        font-size: 14px;
        font-weight: 400;
        transition: background 0.2s;
      `;
      button.addEventListener('mouseenter', () => {
        button.style.background = isDark ? '#374151' : '#f5f5f5';
      });
      button.addEventListener('mouseleave', () => {
        button.style.background = isDark ? '#0f172a' : 'white';
      });
      button.addEventListener('click', () => {
        document.body.removeChild(dialog);
        action();
      });
      return button;
    };

    buttonContainer.appendChild(createButton(option1, () => {
      this.restoreCollectionToExistingWindow(collection, key);
    }));
    buttonContainer.appendChild(createButton(option2, () => {
      this.restoreCollectionToNewWindow(collection, key);
    }));
    buttonContainer.appendChild(createButton(option3, () => {
      this.showNotification(this.getLocalizedText('notification_restore_cancelled'), 'info', { duration: 2000 });
    }));

    dialogContent.appendChild(prompt);
    dialogContent.appendChild(buttonContainer);
    dialog.appendChild(dialogContent);
    document.body.appendChild(dialog);

    // 背景クリックで閉じる
    dialog.addEventListener('click', (e) => {
      if (e.target === dialog) {
        document.body.removeChild(dialog);
        this.showNotification(this.getLocalizedText('notification_restore_cancelled'), 'info', { duration: 2000 });
      }
    });
  }

  async restoreCollectionToExistingWindow(collection, key) {
    try {
      console.log('[GHOST][RESTORE] 既存ウィンドウに復元開始');
      
      // background script経由で管理画面を開く
      await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({
          action: 'openManagerTab'
        }, (response) => {
          if (chrome.runtime.lastError) {
            console.error('[GHOST][RESTORE] 管理画面開封エラー:', chrome.runtime.lastError);
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response && response.success) {
            console.log('[GHOST][RESTORE] 管理画面を開きました');
            resolve(response);
          } else {
            console.error('[GHOST][RESTORE] 管理画面開封失敗:', response?.error);
            reject(new Error(response?.error || 'Failed to open manager'));
          }
        });
      });

      // 現在のウィンドウのタブを取得
      chrome.runtime.sendMessage({ action: 'getCurrentWindowTabs' }, (response) => {
        if (chrome.runtime.lastError || !response?.success) {
          console.error('[GHOST][RESTORE] タブ取得エラー:', chrome.runtime.lastError);
          this.showNotification(this.getLocalizedText('notification_collection_restore_failed'), 'error');
          return;
        }

        const tabs = response.tabs || [];
        console.log('[GHOST][RESTORE] 現在のタブ数:', tabs.length);
        const activeTab = tabs.find(tab => tab.active);
        const windowId = activeTab?.windowId ?? tabs[0]?.windowId;
        const managerUrl = chrome.runtime.getURL('manager/manager.html');
        // 管理画面以外のタブは、ピン留めでも閉じる
        const closeTabIds = tabs
          .filter(tab => {
            // 管理画面タブは除外
            if (tab.url === managerUrl) return false;
            // アクティブタブは除外
            if (activeTab && tab.id === activeTab.id) return false;
            // それ以外はすべて閉じる（ピン留めでも）
            return true;
          })
          .map(tab => tab.id);

        console.log('[GHOST][RESTORE] 閉じるタブ数:', closeTabIds.length, 'windowId:', windowId);

        // 管理画面以外のタブを閉じてから復元
        this.restoreCollectionTabs(collection, {
          closeTabIds: closeTabIds.length > 0 ? closeTabIds : [],
          windowId: typeof windowId === 'number' ? windowId : undefined
        });
      });
    } catch (error) {
      console.error('[GHOST][RESTORE] 復元エラー:', error);
      this.showNotification(this.getLocalizedText('notification_collection_restore_failed'), 'error');
    }
  }

  async restoreCollectionToNewWindow(collection, key) {
    try {
      console.log('[GHOST][RESTORE] 新しいウィンドウに復元開始');
      
      // まず新しいウィンドウを作成してから、そのウィンドウに管理画面を開く
      const managerUrl = chrome.runtime.getURL('manager/manager.html');
      const newWindowResponse = await new Promise((resolve, reject) => {
        chrome.runtime.sendMessage({
          action: 'createNewWindowWithManager',
          url: managerUrl
        }, (response) => {
          if (chrome.runtime.lastError) {
            console.error('[GHOST][RESTORE] 新しいウィンドウ作成エラー:', chrome.runtime.lastError);
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response && response.success) {
            console.log('[GHOST][RESTORE] 新しいウィンドウを作成し、管理画面を開きました, windowId:', response.windowId);
            resolve(response);
          } else {
            console.error('[GHOST][RESTORE] 新しいウィンドウ作成失敗:', response?.error);
            reject(new Error(response?.error || 'Failed to create new window'));
          }
        });
      });

      // 新しいウィンドウで復元
      this.restoreCollectionTabs(collection, {
        closeTabIds: [],
        windowId: newWindowResponse.windowId,
        newWindow: false // windowIdを指定しているので、newWindowフラグはfalse
      });
    } catch (error) {
      console.error('[GHOST][RESTORE] 復元エラー:', error);
      this.showNotification(this.getLocalizedText('notification_collection_restore_failed'), 'error');
    }
  }

  restoreCollectionTabs(collection, options = {}) {
    chrome.runtime.sendMessage({ action: 'restoreCollectionTabs', collection, ...options }, (response) => {
      if (chrome.runtime.lastError) {
        console.error('コレクション復元エラー:', chrome.runtime.lastError);
        this.showNotification(this.getLocalizedText('notification_collection_restore_failed'), 'error');
        return;
      }
      if (!response || !response.success) {
        console.error('コレクション復元失敗:', response?.error);
        this.showNotification(this.getLocalizedText('notification_collection_restore_failed'), 'error');
        return;
      }

      this.showNotification(this.getLocalizedText('notification_collection_restored', [collection.name]), 'success');
    });
  }

  // 指定されたキーのリストにページを追加するメソッド
  addPageToKeyList(key, url, title) {
    const keyList = this.getKeyList(key);
    console.log('[GHOST][SAVE] addPageToKeyList start', { key, url, title });
    
    // 既に同じURLが存在するかチェック
    const existingIndex = keyList.findIndex(item => item.url === url);
    
    if (existingIndex >= 0) {
      // 既に存在する場合は更新
      keyList[existingIndex] = {
        url: url,
        title: title,
        addedAt: Date.now(),
        icon: this.getFaviconUrl(url)
      };
      console.log('[GHOST][SAVE] update existing entry', { key, title });
    } else {
      // 新規追加
      keyList.push({
        url: url,
        title: title,
        addedAt: Date.now(),
        icon: this.getFaviconUrl(url)
      });
      console.log('[GHOST][SAVE] add new entry', { key, title });
    }
    
    // リストを保存
    this.saveKeyLists();
    
    // フィードバックを表示
    this.showKeyListFeedback('add', key, title);
  }

  // 指定されたキーのリストからページを削除するメソッド
  removePageFromKeyList(key, url) {
    const keyList = this.getKeyList(key);
    const existingIndex = keyList.findIndex(item => item.url === url);
    
    console.log('=== リスト削除デバッグ開始 ===');
    console.log('削除対象キー:', key);
    console.log('削除対象URL:', url);
    console.log('削除前のリスト長:', keyList.length);
    console.log('削除対象のインデックス:', existingIndex);
    
    if (existingIndex >= 0) {
      const removedItem = keyList.splice(existingIndex, 1)[0];
      this.saveKeyLists();
      console.log('[GHOST][SAVE] remove entry', { key, title: removedItem.title, remaining: keyList.length });
      this.showKeyListFeedback('remove', key, removedItem.title);
      
      // リストが空になった場合の処理
      if (keyList.length === 0) {
        console.log('⚠️ キーリストが空になりました:', key);
        console.log('handleEmptyKeyListを呼び出します');
        this.handleEmptyKeyList(key);
      } else {
        console.log('リストにはまだアイテムがあります:', keyList.length, '件');
      }
    } else {
      console.log('❌ 削除対象のページが見つかりませんでした');
    }
    console.log('=== リスト削除デバッグ終了 ===');
  }

  // キー別リストのフィードバックを表示するメソッド
  showKeyListFeedback(action, key, title) {
    const isAdded = action === 'add';
    const shortTitle = title.length > 30 ? `${title.substring(0, 30)}...` : title;
    const message = isAdded ? 
      `キー "${key}" に保存しました\n${shortTitle}` : 
      `キー "${key}" から削除しました\n${shortTitle}`;

    this.showNotification(message, isAdded ? 'success' : 'warning', {
      title: isAdded ? 'ページ保存' : 'ページ削除',
      duration: 2800
    });
  }

  // 汎用通知を表示するメソッド（画面上部中央）
  showNotification(message, type = 'info', options = {}) {
    const notificationId = options.id || `ghost-notification-${Date.now()}`;
    const existing = document.getElementById(notificationId);
    if (existing) {
      existing.remove();
    }

    const colors = {
      info: '#3498db',
      success: '#2ecc71',
      warning: '#f39c12',
      error: '#e74c3c'
    };

    const notification = document.createElement('div');
    notification.id = notificationId;
    notification.className = 'ghost-notification';
    notification.style.cssText = `
      position: fixed;
      top: 24px;
      left: 50%;
      transform: translate(-50%, -20px);
      background: ${colors[type] || colors.info};
      color: #fff;
      padding: 14px 24px;
      border-radius: 10px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
      z-index: 10005;
      font-size: 14px;
      font-family: 'Segoe UI', Tahoma, sans-serif;
      max-width: 420px;
      text-align: center;
      opacity: 0;
      transition: all 0.25s ease;
      pointer-events: none;
    `;

    const allowHtml = options.allowHtml === true;
    const safeTitle = options.title ? this.escapeHtml(options.title) : '';
    const processedMessage = allowHtml ? message : this.escapeHtml(message).replace(/\n/g, '<br>');

    notification.innerHTML = `
      ${options.title ? `<div style="font-weight: 600; margin-bottom: 4px;">${safeTitle}</div>` : ''}
      <div>${processedMessage}</div>
    `;

    document.body.appendChild(notification);

    requestAnimationFrame(() => {
      notification.style.opacity = '1';
      notification.style.transform = 'translate(-50%, 0)';
    });

    const duration = options.duration || 3000;
    setTimeout(() => {
      notification.style.opacity = '0';
      notification.style.transform = 'translate(-50%, -20px)';
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 250);
    }, duration);
  }

  // 履歴表示数を更新するメソッド - 常に最大値を使用
  updateHistoryLimit(newLimit) {
    // 履歴制限の選択肢は不要 - 常に最大値を使用
    console.log('履歴制限の選択肢は不要 - 常に最大値を使用');
  }

  // 履歴数選択ドロップダウンの初期値を設定 - 常に最大値を使用
  updateHistoryLimitDropdown() {
    // 履歴制限の選択肢は不要 - 常に最大値を使用
    console.log('履歴制限の選択肢は不要 - 常に最大値を使用');
  }

  // お気に入りリストを表示するメソッド
  displayFavorites(percent = 0) {
    console.log('displayFavorites呼び出し, percent:', percent, 'favorites数:', this.favorites.length);
    const favoritesList = document.getElementById('favorites-list');
    if (!favoritesList) {
      console.log('favorites-list要素が見つかりません');
      return;
    }
    
    // 強制的にHTMLをクリア
    favoritesList.innerHTML = '';
    console.log('favorites-listをクリアしました');
    
    if (this.favorites.length === 0) {
      favoritesList.innerHTML = '<div style="text-align: center; padding: 20px; color: #666;">お気に入りがありません</div>';
      console.log('お気に入りリストが空のため、メッセージを表示');
      return;
    }
    
    console.log('お気に入りリストを表示中:', this.favorites.length, '件');
    
    // 全お気に入りを表示
    this.favorites.forEach((item, index) => {
      const div = document.createElement('div');
      div.className = 'favorite-item';
      
      div.innerHTML = `
        <div class="favorite-content">
          <img src="${item.icon}" class="favorite-favicon" alt="favicon" onerror="this.style.display='none'">
          <div class="favorite-title">${item.title}</div>
          <button class="remove-favorite-button" style="background: none; border: none; cursor: pointer; font-size: 16px; color: #ff4444; margin-left: 5px;">×</button>
        </div>
      `;
      
      // 削除ボタンのクリックイベント
      const removeButton = div.querySelector('.remove-favorite-button');
      if (removeButton) {
        removeButton.addEventListener('click', (e) => {
          e.stopPropagation();
          console.log('お気に入り削除ボタンクリック:', item.title);
          this.removeFavorite(item.url);
        });
      }
      
      div.addEventListener('click', () => window.open(item.url, '_blank'));
      favoritesList.appendChild(div);
      console.log('お気に入りアイテムを追加:', item.title);
    });
    
    // N％位置に応じてスクロール位置を調整
    this.adjustScrollPosition(percent, this.favorites.length);
    console.log('お気に入りリスト表示完了');
  }

  // お気に入りを削除するメソッド
  removeFavorite(url) {
    const index = this.favorites.findIndex(fav => fav.url === url);
    if (index >= 0) {
      this.favorites.splice(index, 1);
      this.saveFavorites();
      console.log('お気に入りを削除しました:', url);
      
      // ヘッダーのお気に入りボタンの状態を更新
      this.updateHeaderFavoriteButton();
      
      // 現在お気に入りリストが表示されている場合は即座に更新
      const currentType = this.getCurrentDisplayType();
      if (currentType === 'favorites') {
        console.log('お気に入りリスト表示中なので即座に更新します');
        // 即座に表示を更新
        this.displayFavorites(this.currentPercent);
      }
      
      // ブックマークリストが表示されている場合も更新（お気に入りボタンの状態を更新するため）
      if (currentType === 'bookmarks') {
        console.log('ブックマークリスト表示中なので更新します');
        this.loadHistoryAndBookmarks(this.currentPercent);
      }
    }
  }

  // ヘッダーのお気に入りボタンの状態を更新するメソッド
  updateHeaderFavoriteButton() {
    const addCurrentPageButton = document.getElementById('add-current-page-favorite');
    if (addCurrentPageButton) {
      const currentUrl = window.location.href;
      const isCurrentPageFavorite = this.favorites.some(fav => fav.url === currentUrl);
      addCurrentPageButton.textContent = isCurrentPageFavorite ? '★' : '☆';
      addCurrentPageButton.style.color = isCurrentPageFavorite ? '#FFD700' : '#ccc';
    }
  }

  // お気に入り追加/削除のフィードバックを表示するメソッド
  showFavoriteFeedback(isAdded, title) {
    const messageKey = isAdded ? 'favoriteAdded' : 'favoriteRemoved';
    const message = `${this.getLocalizedText(messageKey)}\n${title}`;

    this.showNotification(message, isAdded ? 'success' : 'warning', {
      title: isAdded ? 'お気に入り追加' : 'お気に入り削除',
      duration: 3000
    });
  }

  showFavoritesView() {
    console.log('showFavoritesView呼び出し, favorites数:', this.favorites.length);
    this.showGScrollView(this.currentPercent, 'favorites');
    
    // お気に入りリストを強制的に更新
    setTimeout(() => {
      this.displayFavorites(this.currentPercent);
    }, 100);
    
    console.log('お気に入りリストを表示しました');
  }

  showHistoryLimitDropdown() {
    console.log('showHistoryLimitDropdown呼び出し');
    // 履歴制限ドロップダウンは不要 - 常に最大値を使用
    console.log('履歴制限ドロップダウンは不要 - 常に最大値を使用');
  }

  // 現在表示されているタイプを取得
  getCurrentDisplayType() {
    const historyList = document.getElementById('history-list');
    const bookmarkList = document.getElementById('bookmark-list');
    const favoritesList = document.getElementById('favorites-list');
    const keyListContainer = document.getElementById('keylist-list');
    const collectionContainer = document.getElementById('collection-detail');
    const recentlyClosedList = document.getElementById('recently-closed-list');
    
    console.log('=== getCurrentDisplayTypeデバッグ ===');
    console.log('各リストの存在とdisplay状態:');
    console.log('- historyList:', !!historyList, historyList ? historyList.style.display : 'N/A');
    console.log('- bookmarkList:', !!bookmarkList, bookmarkList ? bookmarkList.style.display : 'N/A');
    console.log('- favoritesList:', !!favoritesList, favoritesList ? favoritesList.style.display : 'N/A');
    console.log('- keyListContainer:', !!keyListContainer, keyListContainer ? keyListContainer.style.display : 'N/A');
    console.log('- recentlyClosedList:', !!recentlyClosedList, recentlyClosedList ? recentlyClosedList.style.display : 'N/A');
    
    if (historyList && historyList.style.display === 'block') {
      console.log('→ 判定結果: history');
      return 'history';
    } else if (bookmarkList && bookmarkList.style.display === 'block') {
      console.log('→ 判定結果: bookmarks');
      return 'bookmarks';
    } else if (favoritesList && favoritesList.style.display === 'block') {
      console.log('→ 判定結果: favorites');
      return 'favorites';
    } else if (keyListContainer && keyListContainer.style.display === 'block') {
      console.log('→ 判定結果: keylist');
      return 'keylist';
    } else if (collectionContainer && collectionContainer.style.display === 'block') {
      console.log('→ 判定結果: collection');
      return 'collection';
    } else if (recentlyClosedList && recentlyClosedList.style.display === 'block') {
      console.log('→ 判定結果: recentlyClosed');
      return 'recentlyClosed';
    }
    console.log('→ 判定結果: none');
    return 'none'; // デフォルトを'none'に変更
  }

  // 現在の表示を更新
  refreshCurrentDisplay() {
    const currentType = this.getCurrentDisplayType();
    console.log('現在の表示を更新:', currentType);
    
    if (currentType === 'bookmarks') {
      // ブックマークを再読み込み
      this.loadHistoryAndBookmarks(this.currentPercent);
    } else if (currentType === 'history') {
      // 履歴を再読み込み
      this.loadHistory(this.currentPercent);
    } else if (currentType === 'favorites') {
      // お気に入りを再表示
      this.displayFavorites(this.currentPercent);
    } else if (currentType === 'recentlyClosed') {
      this.displayRecentlyClosed(this.currentPercent);
    }
  }

  // 現在のページをお気に入りに追加するメソッド
  async addCurrentPageToFavorites() {
    console.log('addCurrentPageToFavorites呼び出し');
    const currentUrl = window.location.href;
    const currentTitle = document.title;

    // すでにお気に入りに含まれているかチェック
    const existingIndex = this.favorites.findIndex(fav => fav.url === currentUrl);
    
    if (existingIndex >= 0) {
      // お気に入りから削除
      this.favorites.splice(existingIndex, 1);
      console.log('現在のページをお気に入りから削除しました:', currentTitle);
      this.showFavoriteFeedback(false, currentTitle);
    } else {
      // お気に入りに追加
      const favoriteItem = {
        url: currentUrl,
        title: currentTitle,
        addedAt: Date.now(),
        icon: this.getFaviconUrl(currentUrl)
      };
      this.favorites.push(favoriteItem);
      console.log('現在のページをお気に入りに追加しました:', currentTitle);
      this.showFavoriteFeedback(true, currentTitle);
    }

    // お気に入りリストを保存
    this.saveFavorites();
    
    // ヘッダーのお気に入りボタンの状態を更新
    this.updateHeaderFavoriteButton();
    
    // 現在お気に入りリストが表示されている場合は更新
    const currentType = this.getCurrentDisplayType();
    if (currentType === 'favorites') {
      console.log('お気に入りリスト表示中なので更新します');
      this.displayFavorites(this.currentPercent);
    }
    
    // ブックマークリストが表示されている場合も更新（お気に入りボタンの状態を更新するため）
    if (currentType === 'bookmarks') {
      console.log('ブックマークリスト表示中なので更新します');
      this.loadHistoryAndBookmarks(this.currentPercent);
    }
  }

  // スクロール位置からパーセンテージを更新するメソッド
  updateScrollPositionFromScroll() {
    const gScrollContent = document.querySelector('.g-scroll-content');
    if (!gScrollContent) return;
    
    const scrollTop = gScrollContent.scrollTop;
    const scrollHeight = gScrollContent.scrollHeight;
    const clientHeight = gScrollContent.clientHeight;
    
    // スクロール可能な最大距離を計算
    const maxScrollY = Math.max(0, scrollHeight - clientHeight);
    
    if (maxScrollY > 0) {
      // 現在のスクロール位置からパーセンテージを計算
      const currentPercent = Math.round((scrollTop / maxScrollY) * 100);
      
      // パーセンテージを更新（ただし、ゴーストエリアの位置表示には影響しない）
      console.log('スクロール位置からパーセンテージ更新:', currentPercent);
      
      // スクロール位置を追跡
      this.lastScrollPercent = currentPercent;
      this.lastScrollType = this.getCurrentDisplayType();
    }
  }

}

// メッセージハンドラー
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  // 他のタブからのゴーストモード変更通知
  if (request.action === 'ghostModeChanged') {
    console.log('ゴーストモード変更通知を受信:', request.mode);
    
    if (window.ghostInterface) {
      window.ghostInterface.handleGhostModeChange(request.mode);
      sendResponse({ success: true });
    } else {
      console.log('GhostInterfaceが見つかりません');
      sendResponse({ success: false });
    }
    
    return true;
  }
});

// 拡張機能が読み込まれたときに実行
// 管理画面でもゴーストインターフェースを表示する
const initGhostInterface = () => {
  // 現在のURLを確認
  const currentUrl = window.location.href;
  const managerUrl = chrome.runtime.getURL('manager/manager.html');
  const isManagerPage = currentUrl === managerUrl || currentUrl.startsWith(managerUrl);
  
  console.log('[GHOST] 初期化開始, URL:', currentUrl, '管理画面:', isManagerPage);
  
  // 管理画面でもゴーストインターフェースを初期化
  new GhostInterface();
};

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initGhostInterface);
} else {
  initGhostInterface();
} 